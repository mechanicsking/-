(25.07.02작성)
# 3강 함수
## 정의
### 왜 사용?
c++ 프로그램의 함수 -- c++ 표준 라이브러리(함수와 클래스), 써드 파티 라이브러리(함수와 클래스), 직접 구현한 함수의 클래스   
함수->모듈화->재사용성! -- 코드를 독립적으로 연산으로 분할, 연산들을 재사용    
![image](https://github.com/user-attachments/assets/61e2936a-522f-4675-80a3-f7073d496efb)   
위와 같이 모듈화를 한다면 재사용하기 좋아진다. 각 명령문마다 역할이 분명할때 각각 개별적인 함수로 만들어 처리해주면 코드가 위와 같이 깔끔해진다.     
### 함수를 사용할 때 주의!
함수를 사용할 때 알아야하는 것-->    
함수의 기능을 알아야함,    
함수를 필요로 하는 정보를 알아야 함,    
함수가 리턴하는 것을 알아야함,    
어떤 오류가 발생하는지 알아야 함,    
성능상의 제약에 대해 이해해야함      
    
함수를 사용할 때 몰라도 되는 것-->    
함수가 내부적으로 어떻게 동작하는지      

<cmath> 예시-->수학 연산함수들 제공   
```cpp
cout << sqrt(400.0) << endl; //20;
double result;
result = pow(2.0, 3.0); // 2^3;
```
함수가 내부적으로 어떻게 동작하는지 몰라도 사용할 수 있다.   
### 함수의 정의에 필요한 요소
1. 이름   
-함수의 이름   
-변수의 명명 규칙과 동일   
-의미가 있는 이름이어야 함!    
2. 매개변수 리스트     
-함수에 전달되는 값(인자)들   
-타입이 명시되어야 함   
3. 리턴 타입   
-연산 결과의 반환 타입   
4. 본문(body)   
-함수가 호출되었을 때 실행되는 명령문   
-대괄호("{}") 내부
   
### 함수의 정의(코드 작성법)
따라서 함수의 기본적인 형태는 다음과 같다.   
```cpp
returnType FunctionName(parameters)
{
    statements;

    return 0;
}
```
다음은 함수의 예시이다.   
```cpp
int FunctionName(int a)
{
    statements;

    return 0;
}

void FunctionName(double d)
{
    statements;

    return;  //or 생략
}
```
위의 코드와 같이 반환값이 없는 경우 void로 명시한다.   
### 함수의 호출(작성한 함수 코드를 사용할때)
함수의 호출은 다음과 같이 한다.   
```cpp
void PrintHello()
{
    std::cout << "Hello" << std::endl;
}

int main()
{
    for(int i=0; i<10; i++)
    {
        PrintHello();
    }
    return 0;
}
```
위의 코드에서는 PrintHellow()라는 함수를 하나 정의 하고 이를 main함수에서 호출하여 사용한다. 이를 구분하기 어렵다면 함수 앞에를 확인해보자. 만약 매개변수가 붙어25.07.02작성)
# 3강 함수
## 정의
### 왜 사용?
c++ 프로그램의 함수 -- c++ 표준 라이브러리(함수와 클래스), 써드 파티 라이브러리(함수와 클래스), 직접 구현한 함수의 클래스   
함수->모듈화->재사용성! -- 코드를 독립적으로 연산으로 분할, 연산들을 재사용    
![image](https://github.com/user-attachments/assets/61e2936a-522f-4675-80a3-f7073d496efb)   
위와 같이 모듈화를 한다면 재사용하기 좋아진다. 각 명령문마다 역할이 분명할때 각각 개별적인 함수로 만들어 처리해주면 코드가 위와 같이 깔끔해진다.     
### 함수를 사용할 때 주의!
함수를 사용할 때 알아야하는 것-->    
함수의 기능을 알아야함,    
함수를 필요로 하는 정보를 알아야 함,    
함수가 리턴하는 것을 알아야함,    
어떤 오류가 발생하는지 알아야 함,    
성능상의 제약에 대해 이해해야함      
    
함수를 사용할 때 몰라도 되는 것-->    
함수가 내부적으로 어떻게 동작하는지      

<cmath> 예시-->수학 연산함수들 제공   
```cpp
cout << sqrt(400.0) << endl; //20;
double result;
result = pow(2.0, 3.0); // 2^3;
```
함수가 내부적으로 어떻게 동작하는지 몰라도 사용할 수 있다.   
### 함수의 정의에 필요한 요소
1. 이름   
-함수의 이름   
-변수의 명명 규칙과 동일   
-의미가 있는 이름이어야 함!    
2. 매개변수 리스트     
-함수에 전달되는 값(인자)들   
-타입이 명시되어야 함   
3. 리턴 타입   
-연산 결과의 반환 타입   
4. 본문(body)   
-함수가 호출되었을 때 실행되는 명령문   
-대괄호("{}") 내부
   
### 함수의 정의(코드 작성법)
따라서 함수의 기본적인 형태는 다음과 같다.   
```cpp
returnType FunctionName(parameters)
{
    statements;

    return 0;
}
```
다음은 함수의 예시이다.   
```cpp
int FunctionName(int a)
{
    statements;

    return 0;
}

void FunctionName(double d)
{
    statements;

    return;  //or 생략
}
```
위의 코드와 같이 반환값이 없는 경우 void로 명시한다.   
### 함수의 호출(작성한 함수 코드를 사용할때)
함수의 호출은 다음과 같이 한다.   
```cpp
void PrintHello()
{
    std::cout << "Hello" << std::endl;
}

int main()
{
    for(int i=0; i<10; i++)
    {
        PrintHello();
    }
    return 0;
}
```
위의 코드에서는 PrintHellow()라는 함수를 하나 정의 하고 이를 main함수에서 호출하여 사용한다. 이를 구분하기 어렵다면 함수 앞에를 확인해보자. 만약 타입이 붙어있다면 함수의 정의고 붙어있지 않다면 함수의 사용일 가능성이 높다!!    
다음의 두번째 예시를 확인해 감을 익혀보자.   
```cpp
void PrintWorld()
{
    cout << "World" << endl;
    cout << "from PrintWorld()" << endl;
}

void PrintHello()
{
    cout << "Hello" << endl;
    PrintWorld();
    cout << "from PrintHello()" << endl;
}

int main()
{
    PrintHello();
    cout << "from main()" << endl;
    return 0;
}
```
### 중요!!
컴파일러는 함수의 호출(사용) 이전에 함수의 정의를 알아야 함!!   
```cpp
int main()
{
    SayHello();
    return 0;
}

void SayHello()
{
    cout << "Hello" << endl;
}
```
위와 같이 코드를 구성한다면 오류가 발생한다. 그렇기 때문에 위의 함수에선 main 함수 전에 SayHello함수가 먼저 정의되어야한다.   

## 프로토 타입
함수의 호출 이전에 함수의 정의를 알 수 있어야한다.   
-매개변수가 몇개고, 어떤 타입의 데이터를 리턴하는지를 알려주어야 한다.   
-해결방법 1: 항상 함수의 호출보다 위쪽 라인에 함수를 정의   
   작은 프로그램에서는 Ok   
   일반적으로는 효율적인 방법이 아님   
-해결방법 2: 함수 프로토타입의 사용   
   함수의 전체 정의가 아닌 컴파일러가 알아야 할 부분만을 미리 알려주는 개념   
   전방 선언(forward declaration)이라고도 명칭   
   프로그램의 초기에 위치   
   헤더 파일(.h)의 활용   
### 함수의 프로토타입
-함수를 사용하기 이전에 입력 매개변수와 반환형을 미리 알려주는 명령문   
-함수를 사용할 시점에, 프로토타입과 사용 형식이 맞지 않는다면 오류   
예)
```cpp
int FunctionName(int, std::string); // Prototype

int main()
{
    FunctionName(1, "KHK"); Call(Use)
}

int FunctionName(int a, std::string b) //Deficition
{
    statements;
    return 0;
}
```
이런식으로 앞에 프로토타입을 정의해주면 위와 같이 사용할 수 있다.   
다음은 오류가 발생한 예제이다.    
```cpp
void SayHello(); //Prototype

int main()
{
    SayHello(); //OK
    SayHello(100); //Error
    cout << SayHello(); //Error

    return 0;
}
```
프로토타입 때문에 오류가 발생한 경우이다.   
### 분산된 코드와 함수, compile과 linking
-compile과 linking, 프로토타입에 대한 깊은 이해   
1. 두개의 cpp파일에 모두 다 iostream이 필요한가?   
2. 각 파일이 complie이 정상적으로 이루어지는 이유는?   
3. 만일 Log.cpp에 Log 함수가 없다면 어떤 오류가 발생할까?   
![image](https://github.com/user-attachments/assets/dd577f05-5e0c-4e0b-88b0-37040925d40c)   


## 매개변수(parameter)와 pass-by-value--중요

## return 문

## 기본 인수(default argument)

## 오버로딩--중요

## 함수 호출의 동작 방식--중요

## 포인터와 참조자--중요

## inline 함수

## 재귀 함수(recursive)
