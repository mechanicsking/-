(25.07.02작성)
# 3강 함수
## 정의
### 왜 사용?
c++ 프로그램의 함수 -- c++ 표준 라이브러리(함수와 클래스), 써드 파티 라이브러리(함수와 클래스), 직접 구현한 함수의 클래스   
함수->모듈화->재사용성! -- 코드를 독립적으로 연산으로 분할, 연산들을 재사용    
![image](https://github.com/user-attachments/assets/61e2936a-522f-4675-80a3-f7073d496efb)   
위와 같이 모듈화를 한다면 재사용하기 좋아진다. 각 명령문마다 역할이 분명할때 각각 개별적인 함수로 만들어 처리해주면 코드가 위와 같이 깔끔해진다.     
### 함수를 사용할 때 주의!
함수를 사용할 때 알아야하는 것-->    
함수의 기능을 알아야함,    
함수를 필요로 하는 정보를 알아야 함,    
함수가 리턴하는 것을 알아야함,    
어떤 오류가 발생하는지 알아야 함,    
성능상의 제약에 대해 이해해야함      
    
함수를 사용할 때 몰라도 되는 것-->    
함수가 내부적으로 어떻게 동작하는지      

<cmath> 예시-->수학 연산함수들 제공   
```cpp
cout << sqrt(400.0) << endl; //20;
double result;
result = pow(2.0, 3.0); // 2^3;
```
함수가 내부적으로 어떻게 동작하는지 몰라도 사용할 수 있다.   
### 함수의 정의에 필요한 요소
1. 이름   
-함수의 이름   
-변수의 명명 규칙과 동일   
-의미가 있는 이름이어야 함!    
2. 매개변수 리스트     
-함수에 전달되는 값(인자)들   
-타입이 명시되어야 함   
3. 리턴 타입   
-연산 결과의 반환 타입   
4. 본문(body)   
-함수가 호출되었을 때 실행되는 명령문   
-대괄호("{}") 내부
   
### 함수의 정의(코드 작성법)
따라서 함수의 기본적인 형태는 다음과 같다.   
```cpp
returnType FunctionName(parameters)
{
    statements;

    return 0;
}
```
다음은 함수의 예시이다.   
```cpp
int FunctionName(int a)
{
    statements;

    return 0;
}

void FunctionName(double d)
{
    statements;

    return;  //or 생략
}
```
위의 코드와 같이 반환값이 없는 경우 void로 명시한다.   
### 함수의 호출(작성한 함수 코드를 사용할때)
함수의 호출은 다음과 같이 한다.   
```cpp
void PrintHello()
{
    std::cout << "Hello" << std::endl;
}

int main()
{
    for(int i=0; i<10; i++)
    {
        PrintHello();
    }
    return 0;
}
```
위의 코드에서는 PrintHellow()라는 함수를 하나 정의 하고 이를 main함수에서 호출하여 사용한다. 이를 구분하기 어렵다면 함수 앞에를 확인해보자. 만약 매개변수가 붙어25.07.02작성)
# 3강 함수
## 정의
### 왜 사용?
c++ 프로그램의 함수 -- c++ 표준 라이브러리(함수와 클래스), 써드 파티 라이브러리(함수와 클래스), 직접 구현한 함수의 클래스   
함수->모듈화->재사용성! -- 코드를 독립적으로 연산으로 분할, 연산들을 재사용    
![image](https://github.com/user-attachments/assets/61e2936a-522f-4675-80a3-f7073d496efb)   
위와 같이 모듈화를 한다면 재사용하기 좋아진다. 각 명령문마다 역할이 분명할때 각각 개별적인 함수로 만들어 처리해주면 코드가 위와 같이 깔끔해진다.     
### 함수를 사용할 때 주의!
함수를 사용할 때 알아야하는 것-->    
함수의 기능을 알아야함,    
함수를 필요로 하는 정보를 알아야 함,    
함수가 리턴하는 것을 알아야함,    
어떤 오류가 발생하는지 알아야 함,    
성능상의 제약에 대해 이해해야함      
    
함수를 사용할 때 몰라도 되는 것-->    
함수가 내부적으로 어떻게 동작하는지      

<cmath> 예시-->수학 연산함수들 제공   
```cpp
cout << sqrt(400.0) << endl; //20;
double result;
result = pow(2.0, 3.0); // 2^3;
```
함수가 내부적으로 어떻게 동작하는지 몰라도 사용할 수 있다.   
### 함수의 정의에 필요한 요소
1. 이름   
-함수의 이름   
-변수의 명명 규칙과 동일   
-의미가 있는 이름이어야 함!    
2. 매개변수 리스트     
-함수에 전달되는 값(인자)들   
-타입이 명시되어야 함   
3. 리턴 타입   
-연산 결과의 반환 타입   
4. 본문(body)   
-함수가 호출되었을 때 실행되는 명령문   
-대괄호("{}") 내부
   
### 함수의 정의(코드 작성법)
따라서 함수의 기본적인 형태는 다음과 같다.   
```cpp
returnType FunctionName(parameters)
{
    statements;

    return 0;
}
```
다음은 함수의 예시이다.   
```cpp
int FunctionName(int a)
{
    statements;

    return 0;
}

void FunctionName(double d)
{
    statements;

    return;  //or 생략
}
```
위의 코드와 같이 반환값이 없는 경우 void로 명시한다.   
### 함수의 호출(작성한 함수 코드를 사용할때)
함수의 호출은 다음과 같이 한다.   
```cpp
void PrintHello()
{
    std::cout << "Hello" << std::endl;
}

int main()
{
    for(int i=0; i<10; i++)
    {
        PrintHello();
    }
    return 0;
}
```
위의 코드에서는 PrintHellow()라는 함수를 하나 정의 하고 이를 main함수에서 호출하여 사용한다. 이를 구분하기 어렵다면 함수 앞에를 확인해보자. 만약 타입이 붙어있다면 함수의 정의고 붙어있지 않다면 함수의 사용일 가능성이 높다!!    
다음의 두번째 예시를 확인해 감을 익혀보자.   
```cpp
void PrintWorld()
{
    cout << "World" << endl;
    cout << "from PrintWorld()" << endl;
}

void PrintHello()
{
    cout << "Hello" << endl;
    PrintWorld();
    cout << "from PrintHello()" << endl;
}

int main()
{
    PrintHello();
    cout << "from main()" << endl;
    return 0;
}
```
### 중요!!
컴파일러는 함수의 호출(사용) 이전에 함수의 정의를 알아야 함!!   
```cpp
int main()
{
    SayHello();
    return 0;
}

void SayHello()
{
    cout << "Hello" << endl;
}
```
위와 같이 코드를 구성한다면 오류가 발생한다. 그렇기 때문에 위의 함수에선 main 함수 전에 SayHello함수가 먼저 정의되어야한다.   

## 프로토 타입
함수의 호출 이전에 함수의 정의를 알 수 있어야한다.   
-매개변수가 몇개고, 어떤 타입의 데이터를 리턴하는지를 알려주어야 한다.   
-해결방법 1: 항상 함수의 호출보다 위쪽 라인에 함수를 정의   
   작은 프로그램에서는 Ok   
   일반적으로는 효율적인 방법이 아님   
-해결방법 2: 함수 프로토타입의 사용   
   함수의 전체 정의가 아닌 컴파일러가 알아야 할 부분만을 미리 알려주는 개념   
   전방 선언(forward declaration)이라고도 명칭   
   프로그램의 초기에 위치   
   헤더 파일(.h)의 활용   
### 함수의 프로토타입
-함수를 사용하기 이전에 입력 매개변수와 반환형을 미리 알려주는 명령문   
-함수를 사용할 시점에, 프로토타입과 사용 형식이 맞지 않는다면 오류   
예)
```cpp
int FunctionName(int, std::string); // Prototype

int main()
{
    FunctionName(1, "KHK"); Call(Use)
}

int FunctionName(int a, std::string b) //Deficition
{
    statements;
    return 0;
}
```
이런식으로 앞에 프로토타입을 정의해주면 위와 같이 사용할 수 있다.   
다음은 오류가 발생한 예제이다.    
```cpp
void SayHello(); //Prototype

int main()
{
    SayHello(); //OK
    SayHello(100); //Error
    cout << SayHello(); //Error

    return 0;
}
```
프로토타입 때문에 오류가 발생한 경우이다.   
### 분산된 코드와 함수, compile과 linking
-compile과 linking, 프로토타입에 대한 깊은 이해   
1. 두개의 cpp파일에 모두 다 iostream이 필요한가?   
2. 각 파일이 complie이 정상적으로 이루어지는 이유는?   
3. 만일 Log.cpp에 Log 함수가 없다면 어떤 오류가 발생할까?   
![image](https://github.com/user-attachments/assets/dd577f05-5e0c-4e0b-88b0-37040925d40c)   


## 매개변수(parameter)와 pass-by-value--중요
### 함수 매개변수
함수를 호출할 때, 데이터를 전달할 수 있음--> 함수의 호출에 있어서 전달하는 값은 인수(argument)라 함, 함수의 정의에 있어서 전달하는 값은 인자 또는 매개변수(parameter)라 함   
인수와 매개변수는 개수, 순서와 타입이 일치해야한다.    
예제)
```cpp
int AddNumbers(int,int); // Prototype

int main()
{
    int result = 0;
    result = AddNumbers(100,200); //Call(use)
    return 0;
}

int AddNumbers(int first, int second)) // Definition
{
    return first + second;
}
```
### Pass-by-value 중요!!
함수에 데이터를 전달할 때는 값으로 전달(pass-by-value)됨    
-데이터의 값이 **복사되어** 전달   
함수 내에서는 원본에서 복사해서 만들어진 사본이 사용됨   
-전달된 인수는 함수를 통해 변화되지 않음   
사본을 바꾼다고 원본이 바뀌지 않음   
실수로 값을 변화하는 것을 방지   
**원본을 변화시키는 것이 필요하고나, 복사비용이 높을 때를 위한 방법 존재(포인터/참조자)**   
예제)원본과 사본   
```cpp
void ParamChange(int formal) //formal은 actual의 사본
{
    cout << formal << endl;  //50
    formal = 100;
    cout << formal << endl; //100,  foraml은 100으로 변화
}

int main()
{
    int actual=50;  //원본, Main()함수 안의 actual이라는 변수
    cout << actual << endl; //원본의 값은 50
    ParamChange(actual);  //actual을 함수에 전달
    cout << actual << endl; //50 <-- 원본 값은 변하지 않음!!
    return 0;
}
```
결과는 다음과 같다.   
![image](https://github.com/user-attachments/assets/06bfc2f0-83c4-408f-979c-256457a2ed94)   

## return 문과 기본 인수(default argument)
### 반환(return)
-return 문을 통해서 함수의 결과값을 전달   
void형 반환인 경우 return 문 생략 가능   
-return문은 함수 내 어느 곳에서나 정의 가능    
-return문을 통해 함수는 **즉각적으로 종료**    
### 기본인수
-함수의 선언에서 정의한 모든 매개변수가 전달되어야 함   
-기본 인수를 사용하면 인수가 주어지지 않을 시 기본 값(defult값)을 사용하도록 정의 가능   
동일한 값을 자주 사용할 경우   
-기본값은 함수 프로토타입 또는 정의부에 선언   
프로토타입에서 선언하는 것이 기본   
둘 다 선언해서는 안됨!   
-여러 개의 기본값을 사용할 경우 오른쪽부터 선언해야 함   
예제)   
```cpp
double CalcCost(double baseCost, double taxRate = 0.06, double shipping =3.5);

double CalcCost(double baseCost, double taxRate, double shipping)
{
    return baseCost += (baseCost * taxRate) + shipping;
}

int main()
{
    double cost=0;
    cost = CalcCost(100.0, 0.08, 4.5);
    cost = CalcCost(100.0, 0.08);
    cost = CalcCost(200.0);
    return 0;
}
```
여기서 오른쪽부터 할 수 없다는 말은 double CalcCost(double baseCost= 3.5, double taxRate = 0.06, double shipping );이렇게 할 수 없다는 뜻이다.   

## 오버로딩--중요
### 함수 오버로딩
-서로 다른 매개변수 리스트를 갖는 **동일한 이름**의 함수를 정의하는 것   
-추상화의 한 예   
-다향성의 한 예   
유사한 개념의 함수를 다른 타입에 대해 정의   
-객체지향 프로그램 구현을 위한 중요한 기법 중 하나   
-컴파일러는 주어진 인수와 함수들의 파라메터 정의를 기반으로 개별적인 함수를 구분할 수 있어야 함    
예제)   
```cpp
int AddNumber(int, int);
double AddNumber(double, double);

int main()
{
    cout << AddNumber(10,20) << endl;
    cout << AddNumber(10.0, 20.0) <<endl;
    return 0;
}

int AddNumber(int first, int second)
{
    return first+second;
}
double AddNumber(double first, double second)
{
    return first+second;
}
```
주의할점!!--반환 타입만 다른 오버로딩은 불가능하다는 것에 주의!   
```cpp
int GetValue();
double GetValue();

...
cout << GetValue() << endl;  //?? int가 반환될 지 double이 반환될지 알 수 없음
```

## 함수 호출의 동작 방식--중요

## 포인터와 참조자--중요

## inline 함수

## 재귀 함수(recursive)
