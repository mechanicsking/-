(25.06.24작성)
# Python basics
## matrix 다루기
### matrix를 구현하는 방법
python에서 행렬을 다루기 위해서는 numpy라는 패키지를 사용한다.   

A=[2 4; 5 -6] 
이 행렬을 만들기 위해선 np.array라는 자료 구조 사용   

    A = np.array([[2, 4], [5, -6]])
    print(f'A=\n{A}\n')

    > result
    A = 
    [[ 2  4]
     [ 5 -6]]
## 회전행렬
다음은 회전 행렬을 구현한다. 회전행렬을 구현하고 싶다면 theta를 매개변수로 받는 함수를 구현해준다.   
[x'; y']=[cos(theta) -sin(theta); sin(theta); cos(theta)][x; y]   

    def rot_mat(theta):
        return np.array([
            [np.cos(theta), -np.sin(theta)],
            [np.sin(theta), np.cos(theta))],
        ])

    theta = 0.5
    print(rot_mat(theta))

    # 실행결과
    [[ 0.87758256 -0.47942554]
     [ 0.47942554  0.87758256]]
%%파이썬 기초상식!-def는 함수를 정의할때 사용, return은 그 함수를 통해 불러오는 함수값이다.   
### 행렬곱
.dot 함수 혹은 @기호를 통해 수행한다.   

    # (2 X 2) dot (2 X 1) => (2 X 1)
    A = np.array([[2,4],[5,-6]])
    B = np.array([[2],[2]])
    D = A.dot(B)
    # or
    D_ = A@B
    print(f'A dot B = \n{D}\n')
    print(f'A @ B = \n{D_}\n')

    > result
    D dot B = 
    [[12]
     [-2]]

    D @ B = 
    [[12]
     [-2]]
%%파이썬 기초상식!-print는 화면에 출력해주는데 f를 적어줘야 포맷 문자열 리터럴를 할 수 잇음...사용법-문자열 앞에 f를 붙이고 중괄호 {} 안에 변수나 표현식을 직접 넣어 문자열 안에 값을 삽입할 수 있게 해준다.    
### 행렬의 transpose & inverse

    # Transpose
    A_T = A.transpose()
    print(f'A_T = \n{A_T}\n')
    # or
    print(np.transpose(A))

    # Inverse
    inv_a = np.linalg.inv(A)
    print(f'inv_a = \n{inv_a}\n')

    >>A_T =
    [[ 2  5]
     [ 4 -6]]

    >>inv_a =
    [[ 0.1875   0.125  ]
     [ 0.15625 -0.0625 ]]
%주의점!--역행렬은 모든 행렬이 존재하지 않는다. ex. 로봇팔의 경로를 만들어낼때 로봇팔이 도저히 갈 수 없는 상황일때가 경로에 끼어 있으면 singularity가 발생하기도 한다.   
%역행렬 계산 시 determinant가 0이 되는 상황을 Singular라고 부르며, 이 상황에서는 역행렬을 구할 수 없습니다.   
### 행렬곱과 일반곱을 주의하라!!

    #Element-wise mult & Matrix mult
    print('inv_a * A = \n',inv_a * A)
    print('np.matmul(inv_a, A) = \n', np.matmul(inv_a, A))
    print('inv_a.dot(A) = \n', inv_a.dot(A))
    print('inv_a @ A =\n', inv_a @ A)

    >>inv_a * A =
     [[0.375   0.5    ]
     [0.78125 0.375  ]]
    >>np.matmul(inv_a, A) =
     [[1. 0.]
     [0. 1.]]
    >>inv_a.dot(A) =
     [[1. 0.]
     [0. 1.]]
    >>inv_a @ A =
     [[1. 0.]
     [0. 1.]]
%주의!! *이 기호는 같은 위치의 원소끼리 곱해준다. 행렬곱이 아님. 그래서 np.matmul(), A.dot(B),A @ B를 사용해야함. 이게 행렬곱이다.   
### 회전행렬의 사용
%주의!! numpy 패키지에서는 degree 체계가 아닌 rad체계이기 때문에 이를 주의 해야한다. 

    theta =30 * np.pi /180
    print('Rotation Matrix = \n', rot_mat(theta))

    >>Rotation Matrix =
     [[ 0.8660254 -0.5      ]
     [ 0.5        0.8660254]]
### Identity matrix, Zero matrix

    print(np.identity(3))
    print(np.zeros((2,4)))

    >>[[1. 0. 0.]
     [0. 1. 0.]
     [0. 0. 1.]]
    >>[[0. 0. 0. 0.]
     [0. 0. 0. 0.]]
