(25.07.10 작성)
# 9강 Passive Walker
Passive walker란 다음과 같이 모터의 직접적인 힘이 아닌, 중력에 의한, 가속과 바닥과의 충격량으로 동작하는 시스템을 말한다. 일반적인 모터 제어보다 훨씬 효율적이고, 안정적인 시스템을 갖고 있어 보행을 연구 할 시 가장 기초가 되는 모델이다.    
![image](https://github.com/user-attachments/assets/b041c406-ec33-4926-ae80-d94f131d5dd0)    
따라서 이번 장에서는 이러한 passive dynamic walker model을 해석하고, hybrid system을 적용하여 직접 시뮬레이션까지 진행한다.     
## Passive Walker
passive walker은 2개의 state를 동시에 갖고 있는 로봇이다. 다음 그림과 같이 자유롭게 움직일 수 있는 swing state와 바닥에 고정되어있어 자유롭게 움직일 수 없는 stance state이다.     
![image](https://github.com/user-attachments/assets/f6160d0e-8df9-417a-9476-0530236f8e3e)    
이렇게 한개의 다리는 swing과 stance를 반복하는데 그 사이에 발생하는 이벤트가 있는데 이는 foot-strike라 하며, 이를 기점으로 swing과 stance를 판별한다.   
따라서    
1. leg swing
2. foot strike
3. leg stance

이를 반복하는 hybrid system이다.    

## walker modeling
운동방정식을 세우기 위해서는 다음의 순서를 따른다.    
1. 축설정
2. Homogeneous Matrix
3. Langrange(T-V)
4. E.L -->EOM<swing, stance)

이과정에서 유의할 점으로 Passive Walker는 계속해서 이동하는 로봇이기 때문에 바닥과 접하는 점 C1의 좌표가 계속해서 변화한다. 이러한 상황을 “Floating Base”라고 부른다.
## 첫번째 EOM
### 축설정
먼저 joint와 질점의 좌표를 세워준다.   
![image](https://github.com/user-attachments/assets/cb91ad8a-34b2-490f-bc77-72d12a724288)     
![image](https://github.com/user-attachments/assets/87b6e6c7-4309-4e8f-bc23-88cbbef11a92)    
그다음 축을 붙여준다.    
![image](https://github.com/user-attachments/assets/0601e8e5-9749-4c0d-9377-3ae1e5d59522)    
X0-->X1-->X2로 넘어가는 각각의 H를 구해주면 전체 Kinematics는 알 수 있게 된다. 
여기서 주의해야할 점은 다음과 같다.    
* 편의를 위해 C1의 좌표를 X축 기준으로 설정했다. 이에 따라 회전 행렬식의 요소에도 차이가 생김을 인지해야한다.    
* x1-->x2 사이 각도 변환은 $180-\theta_2$이지만, 방향이 시계방향이므로 -부호가 붙어 $\theta_2-180$이 되게 된다.
### Homogeneous Matrix
다음으로는 이렇게 구한 좌표와 각도를 이용하여 H를 구하고 각각 좌표의 위치를 구해주면 다음과 같다.    
![image](https://github.com/user-attachments/assets/0ecec073-bf7f-4ffc-9112-e8c7dae8db99)    
### Lagrange & E-L
이제 L을 구하기 위해 운동에너지와 위치에너지를 구해준다.   
* 운동에너지    
H를 통해 각 point의 위치를 얻어냈기 때문에 속도는 자코비안을 통해 손쉽게 계산할 수 있다.
hip joint의 무게도 고려하기에 M을 추가해주었다. 그리고 2번째 각속도를 고려할때 첫번째 leg의 각속도를 고려해야하는 것을 인지하자.
![image](https://github.com/user-attachments/assets/a1066db7-efe3-43cc-826b-7194eebd69a9)     
* 위치에너지     
  현재 walker는 기울어진 경사면을 따라 움직이다. 따라서 y좌표를 얻어내기 위해 경사각도 고려해주어야한다. 경사각 r만큼의 회적 변환을 반대로 적용해야 하므로 $R^{-1}$를 곱해주어야하는데 회전매트릭스는 $R^{-1}=R^T$이기에 방정식에 $R^T$가 곱해진 모습을 확인할 수 있다.   
![image](https://github.com/user-attachments/assets/46a1ccc9-3789-4e85-a07a-1fe4885d1b06)

이 시스템은 처음 언급한 것 처럼 hybrid system이기 때문에 2가지 운동방정식을 갖지만 지금까지 우리는 한가지 운동방정식을 구했다. 두번째 운동방정식은 어떻게 구해야할 지 고려해본다.    
## 두번째 EOM
이제 foot strike 시점의 EOM을 구해줄 것이다. 다리가 바닥면과 부딪히는 순간에 또 어떠한 힘이 발생할 것이다. 이 힘은 x, y평면에서 발생하는 힘이다. but, 우리는 joint angle인 theta를 조절하기 때문에 이 사이에 변환을 해주는 자코비안이 필요하게 된다. 따라서 다음의 식이 완성된다.     
<img width="801" height="420" alt="image" src="https://github.com/user-attachments/assets/2aa24bc1-8b0d-44a6-9259-b0893ad4f9ce" />    
수평힘이 작용하는 포인트가 C1과 C2 두가지 포인트가 있기 때문에 C1에 대한 토크와 C2에 대한 토크 두가지를 구해주어야한다.     
그렇다면 위 운동방정식에서 $F_{C_1}, F_{C_2})$는 어떻게 구해야까??    
### Impact map
우리는 과거에 배운것처럼 I=Fdt를 이용해야한다.     
<img width="786" height="402" alt="image" src="https://github.com/user-attachments/assets/4112ca9b-923b-435f-90b9-6adb7997bbce" />    
Walker의 운동방정식 양변에 시간에 대한 순간 적분을 적용하면 Fdt항을 이끌어 낼 수 있으며 이를 충격량 I로 치환할 수 있게 된다.    
충돌이 발생하기 전과 발생한 후의 상황을 다음과 같이 정의하겠다.    
<img width="780" height="307" alt="image" src="https://github.com/user-attachments/assets/ea9ae6a1-63dc-47c1-9c39-dd34614c90da" />     
아까의 운동방정식을 미소시간으로 적분을 해준다면 다음의 식이 된다.    
<img width="702" height="370" alt="image" src="https://github.com/user-attachments/assets/2ff1afc9-7114-4157-a217-91a667f322d2" />    
* 여기서 C1은 고정되어있는 point이다. 그렇기에 어떠한 충격이 발생하거나 외력이 발생하지 않기에 작용하는 힘은 0이다. --> $J_{C_2}^TF_{C_2}dt=0$
* 다음으로 B term은 M,C,G중 C와 G가 함쳐진 텀인데 이는 매우 짧은 시간에 대한 적분을 계산하기 때문에 0으로 가정할 수 있다. --> $B(\theta,\theta dot)dt =0$
* 마지막으로 충돌한 후 C_2의 순간 속도는 0이라고 가정한다.    

이제 남은 수식들을 정리하고 속도에 대한 제약조건까지 모두 적용하면 아래와 같은 2개의 수식을 얻을 수 있으며, 이를 행렬 형태로 나타낼 수 있다.    
<img width="676" height="366" alt="image" src="https://github.com/user-attachments/assets/8104cd82-a3fb-4055-ab87-ad14cc6eb3f2" />
추가되는 항에 대해 제약조건을 추가하여 전체 시스템을 해석 가능하게 하는 이러한 기법은 impact map이라고 지칭하며, 바닥과 상호작용하는 보행 로봇의 해석에 있어 필수적으로 사용되는 기법이다.   
<img width="812" height="667" alt="image" src="https://github.com/user-attachments/assets/dd65a438-fbb5-470f-9cc2-ab5954223625" />     
이제 우리는 코드를 구현할 것이다. 코드를 구현할 때 solveivp를 사용하며 swing과 stance를 번갈아가며 실행 시킬 것이다. 이 둘의 스위칭 조건이 foot strike이다. 어떤 시점이 이 foot strike가 발생되는 시점이 될까? bouncing ball에서는 y=0이 되는 시점이 event가 발생하는 시점이였다. 이 walker의 switch 조건에 대해 살펴본다. foot strike --> swing이 발생하기 위한 조건으로 이는 swing leg가 바닥면과 닿는 시점이 된다.    
<img width="640" height="363" alt="image" src="https://github.com/user-attachments/assets/04eed7a1-89e0-46f7-a9a6-05ef59920b63" />     
위의 그림과 같이 event가 발생할 때에는 $-2\theta_1=\theta_2$를 만족한다. 그렇기에 2\theta_1+\theta_2=0$를 만족한다. but, 이때 주의 해야할 예외가 있다. $\theta_1=\theta_2=0$일 때이다. 이때에도 식이 성립하기 때문에 if문을 이용해 이 상황을 없애주어야한다.    
다음으로 switch가 발생한 직후에는 새로운 state를 부여하여 새로운 theta1과 theta2를 정의해주어 다음 swing을 준비시켜야한다.      
<img width="748" height="365" alt="image" src="https://github.com/user-attachments/assets/3805b337-adda-4a93-b320-98b063ed2902" />
새롭게 정의된 theta2는 원래 theta2+의 반대방향이기 때문에 그냥 -만 붙여주었고, 새롭게 정의된 theta1의 경우 theta2+에 -theta1만큼 빼주었기 때문에 theta2+ + theta1+가 된다.    
이렇게 필요한 모든 개념들을 살펴보았다. 이제 소스코드를 살펴보자.    
## Stability of Walking & Poincaré map 소스코드
먼저 main_walker_naive_guess.py코드를 실행해보자. 
<img width="761" height="472" alt="image" src="https://github.com/user-attachments/assets/b6b99d0b-69d6-4b8e-aa01-96b5f79b57c2" />     
코드를 실행해 보면 step이 계속될수록 보폭이 작아지면서 passive walker가 불안정해지는 모습을 확인 할 수 있다. 보행의 안정성을 보장하기 위해 어떠한 추가작업이 필요할지, 수학적 접근을 통해 알아보자.    
### Poincaré map
현재 walker는 동일한 보행을 반복적으로 실행하고 있다. 매번 보행이 반복될 때마다 발생하는 오차가 누적되어 점차 불안정해지고 있는 상황인 것이다. 
이를 수식적으로 나타내보자. 보폭을 거치기 전과 거친 후의 state를 나타내는 함수를 F(x)라고 하였을 때 보폭을 거치 뒤의 상태를 $x_{i+1}=F(x_i)$ 로 나타낼 수 있다.     
<img width="752" height="281" alt="image" src="https://github.com/user-attachments/assets/a728d18e-720b-464b-9d9e-dd7b024ec80f" />    
우리는 이런 $x_{i+1}$ 와 $x_i$ 사이의 간극을 줄이는 것이 오차를 줄이는 것이라고 알 수 있다.    
F(x)를 거칠 때마다 발생하는 차이 dx는 곧 Jacobian이 된다. 우리는 이러한 jacobian을 최소화하는 것이 목적이된다. 더불어 jacobian의 eigen value를 통해 stable 여부를 확인할 수 있다. (모든 eigenvalue가 1보다 작으면 시스템이 stable하다는 뜻이 된다.)    
<img width="730" height="441" alt="image" src="https://github.com/user-attachments/assets/abfa6df9-c8ed-4207-a09e-7341dd667c69" />       
현재 상황은 leg의 각도를 직접적으로 제어하지 않고 오로지 경사에 의한 중력, 초기 속도를 통해 보행하게 된다.    
## 코드 구현
코드는 총 2가지의 코드를 구현할 것이다. 먼저, 복잡한 운동방정식을 계산하는 sympy code와 이 운동방정식을 이용하여 시뮬레이션을 작동시키는 시뮬레이션 코드 2종류를 구현 시킬 것이다. 
먼저 derive_walker.py코드에서는 아래와 같은 수식을 구현한다.   
1. kinematics
2. E-L Method
3. single_stance
4. Heelstrike

다음으로 main_walker.py코드에서는 위에서 계산된 운동방정식을 바탕으로 시뮬레이션을 진행한다. solve_ivp를 통해 terminal condition이전까지 미분방정식의 해를 구해준다. 
* n_steps
* one_steps
  * single_stance
  * footstrike

### derive_walker.py 
```python
import sympy as sy

# define state variables
# 각도, 각속도, 각가속도
theta1, theta2 = sy.symbols('theta1 theta2', real=True)
omega1, omega2 = sy.symbols('omega1 omega2', real=True)
alpha1, alpha2 = sy.symbols('alpha1 alpha2', real=True)

# 충돌 후의 각도와 각속도
theta1_n, theta2_n = sy.symbols('theta1_n theta2_n', real=True)
omega1_n, omega2_n = sy.symbols('omega1_n omega2_n', real=True)

# 변위, 속도, 가속도
x, y = sy.symbols('x y', real=True)
vx, vy = sy.symbols('vx vy', real=True)
ax, ay = sy.symbols('ax ay', real=True)

# m, M : leg mass, body mass
# I : body moment of inertia
# g : gravity
# c, l : leg length, body length
# gam : slope angle
m, M, I, g = sy.symbols('m M I g', real=True)
c, l, gam = sy.symbols('c l gam', real=True)

######################
# Step 1. kinematics #
######################

pi = sy.pi
cos = sy.cos
sin = sy.sin

angle_1 = pi/2 + theta1

# floating base => x, y, 1
H_01 = sy.Matrix([
    [cos(angle_1), -sin(angle_1), x],
    [sin(angle_1), cos(angle_1), y],
    [0, 0, 1]
])

# 각도 유의
angle_2 = theta2 - pi
H_12 = sy.Matrix([
    [cos(angle_2), -sin(angle_2), l],
    [sin(angle_2), cos(angle_2), 0],
    [0, 0, 1]
])

H_02 = H_01 * H_12

C1 = sy.Matrix([x, y, 1])
H = H_01 * sy.Matrix([l, 0, 1])
C2 = H_02 * sy.Matrix([l, 0, 1])

G1 = H_01 * sy.Matrix([l-c, 0, 1])
G2 = H_02 * sy.Matrix([c, 0, 1])

# print(f"H: {H}")
# print(f"G1: {G1}")
# print(f"G2: {G2}")
# print(f"C1: {C1}")
# print(f"C2: {C2}")

####################
# Step 2. velocity #
####################

q = sy.Matrix([x, y, theta1, theta2])
q_d = sy.Matrix([vx, vy, omega1, omega2])

H_xy = sy.Matrix([H[0], H[1]])
G1_xy = sy.Matrix([G1[0], G1[1]])
G2_xy = sy.Matrix([G2[0], G2[1]])

v_H = H_xy.jacobian(q) * q_d
v_G1 = G1_xy.jacobian(q) * q_d
v_G2 = G2_xy.jacobian(q) * q_d

# print()
# print(f"v_H: {v_H}")
# print(f"v_G1: {v_G1}")
# print(f"v_G2: {v_G2}")

######################
# Step 3. E-L Method #
######################

# 위치에너지를 위해 y값에 경사각 반영
H_og = sy.Matrix([
    [cos(-gam), -sin(-gam), 0],
    [sin(-gam), cos(-gam), 0],
    [0, 0, 1]
])

R_H = H_og * H
R_G1 = H_og * G1
R_G2 = H_og * G2

# print(R_H[1])
# print(R_G1[1])
# print(R_G2[1])

T = 0.5 * M * v_H.dot(v_H) + \
    0.5 * m * v_G1.dot(v_G1) + \
    0.5 * m * v_G2.dot(v_G2) + \
    0.5 * I * omega1**2 + \
    0.5 * I * (omega1 + omega2) ** 2

V = m * g * R_G1[1] + \
    m * g * R_G2[1] + \
    M * g * R_H[1]

L = T - V

# print(f"T: {T}")
# print(f"V: {V}")
# print(f"L: {L}")

# Lagrange Equation
dL_dq_d = []
dt_dL_dq_d = []
dL_dq = []
q_dd = sy.Matrix([ax, ay, alpha1, alpha2])

EOM = []

for i in range(len(q_dd)):
    dL_dq_d.append(sy.diff(L, q_d[i]))
    temp = 0
    for j in range(len(q_dd)):
        temp += sy.diff(dL_dq_d[i], q[j]) * q_d[j] + \
                sy.diff(dL_dq_d[i], q_d[j]) * q_dd[j]
    dt_dL_dq_d.append(temp)
    dL_dq.append(sy.diff(L, q[i]))
    EOM.append(dt_dL_dq_d[i] - dL_dq[i])

EOM = sy.Matrix(EOM)
# print(EOM)

#########################
# Step 4. single_stance #
#########################

# Ax = b
A_ss = EOM.jacobian(q_dd)
b_ss = []

for i in range(len(q_dd)):
    b_ss.append(-1 * EOM[i].subs([(ax, 0), (ay, 0), (alpha1, 0), (alpha2, 0)]))

print(f'A_ss[2,2]: {sy.simplify(A_ss[2,2])}')
print(f'A_ss[2,3]: {sy.simplify(A_ss[2,3])}')
print(f'A_ss[3,2]: {sy.simplify(A_ss[3,2])}')
print(f'A_ss[3,3]: {sy.simplify(A_ss[3,3])}')

# # when real problem, use this
# print("A_ss = np.array([ [A22, A23], [A32, A33] ])")
# print("b_ss = np.array([ b2, b3 ])")
# print("q_dd = np.linalg.inv(A_ss).dot(b_ss)")

######################
# Step 5. Heelstrike #
######################

C2_xy = sy.Matrix([C2[0], C2[1]])
J_C2 = C2_xy.jacobian(q)

A_n_hs = A_ss.subs([(theta1, theta1_n), (theta2, theta2_n)])
J_n_sw = J_C2.subs([(theta1, theta1_n), (theta2, theta2_n)])

# hs equations
print('J11 = ', sy.simplify(J_n_sw[0, 0]))
print('J12 = ', sy.simplify(J_n_sw[0, 1]))
print('J13 = ', sy.simplify(J_n_sw[0, 2]))
print('J14 = ', sy.simplify(J_n_sw[0, 3]))
print('J21 = ', sy.simplify(J_n_sw[1, 0]))
print('J22 = ', sy.simplify(J_n_sw[1, 1]))
print('J23 = ', sy.simplify(J_n_sw[1, 2]))
print('J24 = ', sy.simplify(J_n_sw[1, 3]), '\n')

# print('J = np.array([[J11, J12, J13, J14], [J21,J22,J23,J24]])','\n');

# A_n_hs는 단순히 theta1, theta2 대신에 theta1_n, theta2_n 넣은 것
print('A11 = ', sy.simplify(A_n_hs[0, 0]))
print('A12 = ', sy.simplify(A_n_hs[0, 1]))
print('A13 = ', sy.simplify(A_n_hs[0, 2]))
print('A14 = ', sy.simplify(A_n_hs[0, 3]))

print('A21 = ', sy.simplify(A_n_hs[1, 0]))
print('A22 = ', sy.simplify(A_n_hs[1, 1]))
print('A23 = ', sy.simplify(A_n_hs[1, 2]))
print('A24 = ', sy.simplify(A_n_hs[1, 3]))

print('A31 = ', sy.simplify(A_n_hs[2, 0]))
print('A32 = ', sy.simplify(A_n_hs[2, 1]))
print('A33 = ', sy.simplify(A_n_hs[2, 2]))
print('A34 = ', sy.simplify(A_n_hs[2, 3]))

print('A41 = ', sy.simplify(A_n_hs[3, 0]))
print('A42 = ', sy.simplify(A_n_hs[3, 1]))
print('A43 = ', sy.simplify(A_n_hs[3, 2]))
print('A44 = ', sy.simplify(A_n_hs[3, 3]))

# Ax = b를 다시 세워보자. (여기서부터는 numpy가 사용된다.)
#
# z_d(+)와 I_c2가 목표이다.
# [ [ M -J_c.T ], [ J_c.T 0 ] ] * [ z_d(+) I_c2 ] = [ M*z_d(-) 0 ]

# 충돌 후 vx, vy는 0이며, 각속도는 구해야 한다.
# M*z_d(-) => A_n_hs.dot([0, 0, omega1_n, omega2_n])

"""
A_hs = np.block([
    [A_n_hs, -np.transpose(J_n_sw) ],
    [J_n_sw, np.zeros((2,2))]
])

b_hs = np.block([
    A_n_hs.dot([0, 0, omega1_n, omega2_n]),
    np.zeros((2,1))
])

# x_hs => [vx(+), vy(+), omega1(+), omega2(+) ]
x_hs = np.linalg.inv(A_hs).dot(b_hs)

# switch condition
omega1 = x_hs[2] + x_hs[3]
omega2 = -x_hs[3]
"""
```
코드는 다음과 같다. step3까지는 이제껏 우리가 해왔던 것이기에 읽어만 보아도 어떠한 코드인지 알 수 있다. 주의해야할 점은 모델 전체가 이동하는 floating base이기 때문에 C1의 좌표가 (x, y, 1)이 된다는 점을 유의해야한다.      
step4를 살펴보자.     
passive walker는 swing-contact를 반복하며 각 상태 전환 시마다 다른 시스템을 갖는 hybrid system이다. 따라서 swing을 single_stance라고 이름을 붙였다. 외력이 발생하지 않는 이 single stance상황에서는 EOM의 우변이 0이 될 것이다. 그렇기에 Ax=b를 만족시키는 matrix A와 vector b를 계산한다.    
```python
#########################
# Step 4. single_stance #
#########################

# Ax = b
A_ss = EOM.jacobian(q_dd)
b_ss = []

for i in range(len(q_dd)):
    b_ss.append(-1 * EOM[i].subs([(ax, 0), (ay, 0), (alpha1, 0), (alpha2, 0)]))

print(f'A_ss[2,2]: {sy.simplify(A_ss[2,2])}')
print(f'A_ss[2,3]: {sy.simplify(A_ss[2,3])}')
print(f'A_ss[3,2]: {sy.simplify(A_ss[3,2])}')
print(f'A_ss[3,3]: {sy.simplify(A_ss[3,3])}')
# # when real problem, use this
# print("A_ss = np.array([ [A22, A23], [A32, A33] ])")
# print("b_ss = np.array([ b2, b3 ])")
# print("q_dd = np.linalg.inv(A_ss).dot(b_ss)")
```
A_ss = EOM.jacobian(q_dd)여기에서는 EOM에서 가속도에 대한 계수 행렬을 구하기 위해서 jacobian을 해주게 된다. 가속도항으로 미분해주면 가속도항의 계수만 남기에 이러한 방식을 사용한다면 A를 쉽게 구할 수 있게 되낟. 다음은 b를 구하는 과정이다.     
b항은 가속도항이 없는 비관성항이기 때문에 모든 가속도항에 0을 넣어주게 된다. 부호(-1)를 곱하는 이유는 형태를 마추기 위함이다.    
그리고 우리는 각가속도 부분만 관심 있기 때문에 [2,2]부터 [3,3]까지의 matrix만 사용하게 된다.   
다음은 step5이다.    

