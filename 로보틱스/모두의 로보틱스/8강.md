(25.07.07 작성)
# 8강 Bouncing ball, a hybrid system
우리는 지금까지 라그랑지안을 통해 운동방정식을 세우는 방법에 대해서 학습하였다.    
하지만 벽과 충동하거나, 강한 외력이 작용하면 시스템의 운동 상태가 변화하게 된다. 이를 로보틱스에서는 Hybrid system이라고 한다. 보행로봇이 대표적인 예시이다.     
이번 장에서 구현해 볼 것은 바닥에 튀는 공이다.    
## Bouncing ball system
![image](https://github.com/user-attachments/assets/4707b970-01f4-40d3-8e0a-7138e8992aa3)     
바닥과 충돌한 공은 탄성계수만큼의 속도 감소 후 다시 위로 튀어오르고, 모든 에너지가 사라질 때까지 이과정을 반복한다. (상수 e는 물체와 바닥면과의 충돌 시 사용되는 탄성계수이다.      
물체에 작용하는 힘은 중력과 더불어 속도의 제곱에 비례하는 항력(drag force)가 있다.    
## 코드 구현
ball_bounce.py코드를 실행해보면 다음과 같은 시뮬레이션이 작동하고, 다음의 그래프가 생성된다.    
![image](https://github.com/user-attachments/assets/b619123f-3f5a-4ffe-8c2f-723b54a18e33)     
![image](https://github.com/user-attachments/assets/857cf08b-9e45-48eb-b86d-1b862efa093f)   

따라서 이 시스템은 공이 바닥과 충돌하는 순간, 충돌하기 전에 자유낙하하는 시스템 이 두가지의 시스템을 가지고 있다.    
그렇기에 hybrid system이 되게 된다.    
이 시스템을 파이썬으로 구현하기 위해 알아야하는 패키지가 있는데 바로, solve ivp 패키지이다.  
### solve_ivp
solve_ivp는 odeint와 비슷하게 미분방정식이 주어졌을 때 그것의 값을 수치적 적분을 통해 사용자에게 알려준다.   
solve_ivp는 “initial value problem for a system of ODEs”의 약자로, 미분 방정식과 초기 조건이 주어지면 해당 조건을 바탕으로 수치적인 계산값을 도출해준다.    
예시 코드는 다음과 같다.    
```python
import matplotlib.pyplot as plt
import numpy as np
from scipy.integrate import solve_ivp


# differential equation
def dydt(t, y):
    return -y + 2*np.sin(t)

ts = np.linspace(0, 10, 100)
initial_state = (1, 1)
sol = solve_ivp(dydt, t_span=(0, 10), y0=[10], t_eval=ts)

t = sol.t
y = sol.y[0]

plt.plot(t, y)
plt.show()
```
이 코드는 -y + 2*np.sin(t)와 같은 미분방정식이 있을 때, solve_ivp를 통해 그래프를 그리는 코드이다.   
solve_ivp의 매개변수는 다음과 같다.    
![image](https://github.com/user-attachments/assets/1040e8c4-4f17-47d9-8543-bec59f3f18ad)    
solve_ivp의 return값은 다음과 같다.   
![image](https://github.com/user-attachments/assets/f37a9e67-9af1-46db-a5c6-f19b4f7cfb94)    
만약 두개의 변수(ex, x, y)일 경우 x = sol.y[0], y = sol.y[1]로 구해주면 된다.    

다음은 다변수일때의 코드 예시이다.    
```python
from scipy import integrate
import numpy as np
import matplotlib.pyplot as plt

def f(t, r):
    x, y = r
    
    fx = np.cos(y)
    fy = np.sin(x)
    
    return fx, fy

sol = integrate.solve_ivp(
    f, t_span=(0,10), y0=(1,1),
    t_eval=np.linspace(0,10,100),
)

t = sol.t
x, y = sol.y
plt.plot(x, y)
plt.axis("scaled")
plt.show()
```
### solve_ivp-event
위 코드와 같이 다변수 함수의 경우 initial state에 list가 아닌 tuple이 적용되며, 이느 방정식 함수 내부에서 따로 파싱된다.   
여기까지 보면 odeint와 별로 다른것이 없다. 하지만 solve_ivp에 특이한 기능이 있는데 그것은 바로 **Event** 라는 기능이다.   
다음은 event를 실행한 예시 코드이다.    
```python
import matplotlib.pyplot as plt
import numpy as np
from scipy.integrate import solve_ivp


# differential equation
def dydt(t, y):
    return -y + 2*np.sin(t)


def event(t, y):
    return y[0] - 1


event.terminal = False
event.direction = 0

ts = np.linspace(0, 10, 100)
initial_state = (1, 1)
sol = solve_ivp(dydt, t_span=(0, 10), y0=[10], t_eval=ts, events=event)

t = sol.t
y = sol.y[0]
events = sol.t_events[0]

plt.plot(t, y)
for point in events:
    plt.plot(point, 1, color='green', marker='o', markersize=10)
plt.show()
```
이 코드를 실행하면 다음과 같은 figure가 생성된다.    
![image](https://github.com/user-attachments/assets/d21fa78c-d6b1-4400-a58e-2748e03dba6e)     
다음과 같이 y=1를 만족하는 순간들을 탐지해주는 기능이 event이다.   
event를 실행하는 방법은 다음과 같다.    
solve_ivp에 events라는 파트에 우리가 정의한 event라는 함수를 넣어주게 된다.    
def event(t, y):    
    return y[0] - 1     
다음은 event함수인데 event함수의 return값은 항상 0이 되게 구성해주어야한다.   
여기서 또 알아야할 부분이 solve_int는 t_span과 t_eval이라는 두 가지 시간 정보를 받는데, event를 탐지하는 evaluation 작업들은 t_eval에서 주어진 시간 영역에서만 탐지를 하게 된다. t_span의 경우는 전체 시간범위를 말하기 때문에 t_eval은 t_span보다 작거나 같아야한다.    
event안에는 terminal과 direction이라는 옵션이 있다.   
```
event.terminal = False
event.direction = 0
```
![image](https://github.com/user-attachments/assets/36c4ff2f-3e3c-4660-859f-f1a65886820b)    
-1일때는 다음과 같이 표시된다.    
![image](https://github.com/user-attachments/assets/05c5f638-1a07-4e9e-8ed3-91b8b27fc182)    


이렇게 solve_ivp를 알아보았다. 이 solve_ivp가 boucing ball 코드에서 어떻게 사용되는지 알아보겟다. 

