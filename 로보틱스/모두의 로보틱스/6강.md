(25.07.03 작성)
# 6강 Double pendulum
이번 장에서는 sympy를 통해 단순한 질점이 아닌 로봇팔과 같은 2 DOF를 갖는 double pendulum의 운동방정식을 구현하고 시뮬레이션해볼 것이다.   
이러한 개발을 위해서 절차는 다음과 같다.   
1. 좌표축을 설정하고, 각 좌표축 사이의 Homogeneous Matrix를 계산한다.
2. 운동에너지와 위치에너지, 라그랑지안을 구한다.
3. 이를 통해 Euler-Lagrange equation을 뽑아내서 이것으로 EOM을 얻어낸다.
4. 그 후 시뮬레이션을 진행한다.

## 1.좌표축 설정 및 H 구하기
먼저 좌표계를 통한 kinematics해석을 위해 그림을 작성한다. 다음의 그림과 같이 총 3개의 다른 좌표계가 존재하며 이들 사이 변환 행렬을 구해줘야한다.   
![image](https://github.com/user-attachments/assets/92293fab-1a95-4071-b003-32fd63c97ed1)    
### O0, O1 변환
천장에 매달린 기준으로 좌표계를 잡았기 때문에 joint각도에 270을 더해야 한다.   
![image](https://github.com/user-attachments/assets/c31cfd03-4d6e-4917-b1b5-a31ee2310d31)   
### O1, O2 변환
![image](https://github.com/user-attachments/assets/81584f0e-7891-48fb-afe3-5e2d2c6793b8)   
O0, O2변환은 Homogeneous Matrix의 특성을 이용하여 구해준다.  
![image](https://github.com/user-attachments/assets/2b0f37dc-d4e9-42a8-b935-13ffc6bba1fc)    
여기까지 우리는 일단 FK을 다 구해두었다. 이제 Lagrangian을 구해서 운동방정식을 구해주어야한다.   
## 2.운동에너지, 위치에너지, 라그랑지안 구하기
여기서 주의할 점은 운동에너지와 위치에너지를 구하기 위해선 연결점이 아닌 각 질점의 속도와 y좌표를 구해야 한다. 지금의 좌표를 구하고 직접 미분하여 속도를 계산하였지만, 이후에는 자코비안과 sympy를 사용하여 손쉽게 구할 예정이다.   
![image](https://github.com/user-attachments/assets/ca25cd2a-b977-498b-ac33-c1dcde3d6d80)
밑의 사진은 위치 에너지와 운동에너지를 통해 라그랑지안을 구한 모습이다. 현재 기준 좌표계는 x, y 직교 좌표계가 아닌 각도 좌표계이다. (실제 제어시에도 joint angle, velocity, torque를 제어할 것이기 때문) --> 따라서 모든 위치, 속도, 좌표는 $/theta_1, /theta_2$에 관한 식이 된다.   
![image](https://github.com/user-attachments/assets/d64cf328-55dc-4c34-86c2-3d5707cf1032)    
여기서 주의할 점은 운동에너지에 수평운동에너지+회전운동에너지 모두를 고려해줘야한다.   
## 3.E-L equation, EOM
이제 EL equation을 구해야하는데 이때 5강에서 구현한 sympy함수를 사용할 것이다.  
![image](https://github.com/user-attachments/assets/a7000d61-c0dd-4e05-9246-e765eb44111f)   
이렇게 EOM을 구했다면 전체 수식을 아래와 같이 행렬 형태로 간소화 할 수 있다.    
![image](https://github.com/user-attachments/assets/b7b9c10d-2a6a-4a04-b263-545d20ea606f)   
운동방정식을 작성할 땐 보통, M(theta_dd)+C(theta_d, theta)+G(theta)=sth 이런식으로 작성한다.   

## 4.코드 구현 
이 예시에서의 코드는 크게 두 부분으로 나뉘어진다.    
1. EOM을 계산하는 sympy 코드 - derive_double_pendulum.py   
2. 시뮬레이션을 통한 시각화 코드 - main_double_pendulum.py    

먼저 운동방정식을 도출 하는 코드를 실행하면 운동방정식과 M, C, G 행렬에 대한 모든 element를 출력해준다.   
![image](https://github.com/user-attachments/assets/849a2150-ae1d-415d-8ea3-d79ba01dfbe8)    
derive_double_pendulum.py 코드는 다음과 같다.   
```python
import sympy as sy

# define symbolic quantities
theta1, theta2 = sy.symbols('theta1 theta2', real=True)
m1, m2 = sy.symbols('m1 m2', real=True)
l1, l2 = sy.symbols('l1 l2', real=True)
c1, c2 = sy.symbols('c1 c2', real=True)
I1, I2 = sy.symbols('I1 I2', real=True)
g = sy.symbols('g', real=True)

# position vectors
# link1 frame to world frame
theta1_ = 3*sy.pi/2 + theta1
H_01 = sy.Matrix([
    [sy.cos(theta1_), -sy.sin(theta1_), 0],
    [sy.sin(theta1_),  sy.cos(theta1_), 0],
    [0, 0, 1]
])

# link2 frame to world frame
H_12 = sy.Matrix([
    [sy.cos(theta2), -sy.sin(theta2), l1],
    [sy.sin(theta2),  sy.cos(theta2), 0],
    [0, 0, 1]
])
H_02 = H_01 * H_12

# c1 in world frame
G1 = H_01 * sy.Matrix([c1, 0, 1])
G1_xy = sy.Matrix([G1[0], G1[1]])

# c2 in world frame
G2 = H_02 * sy.Matrix([c2, 0, 1])
G2_xy = sy.Matrix([G2[0], G2[1]])

# velocity vectors
theta1_d, theta2_d = sy.symbols('theta1_d theta2_d', real=True)
q = sy.Matrix([theta1, theta2])
q_d = sy.Matrix([theta1_d, theta2_d])

v_G1 = G1_xy.jacobian(q) * q_d
v_G2 = G2_xy.jacobian(q) * q_d

# kinetic energy
T1 = 0.5*m1*v_G1.dot(v_G1) + 0.5*I1*theta1_d**2
T2 = 0.5*m2*v_G2.dot(v_G2) + 0.5*I2*(theta1_d+theta2_d)**2
T = T1 + T2

# potential energy
V1 = m1*g*G1[1]
V2 = m2*g*G2[1]
V = V1 + V2

# Lagrangian
L = T - V

# Lagrange equation
theta1_dd, theta2_dd = sy.symbols('theta1_dd theta2_dd', real=True)
q_dd = sy.Matrix([theta1_dd, theta2_dd])

dL_dq_d = []
dt_dL_dq_d = []
dL_dq = []
EOM = []

# Derive equations
for i in range(len(q)):
    dL_dq_d.append(sy.diff(L, q_d[i]))
    temp = 0
    for j in range(len(q)):
        temp += sy.diff(dL_dq_d[i], q[j]) * q_d[j] + \
                sy.diff(dL_dq_d[i], q_d[j]) * q_dd[j]

    dt_dL_dq_d.append(temp)
    dL_dq.append(sy.diff(L, q[i]))
    # 현재 외력이 0이므로 이 두개 항만 있다.
    EOM.append(dt_dL_dq_d[i] - dL_dq[i])

# EOM_0 = A11 theta1ddot + A12 theta2ddot - b1 = 0
# EOM_1 = A21 theta1ddot + A22 theta2ddot - b2 = 0
EOM = sy.Matrix([EOM[0], EOM[1]])
print('EOM_0 = ', sy.simplify(EOM[0]))
print('EOM_1 = ', sy.simplify(EOM[1]), '\n')

# M(q)*q_dd + C(q, q_d)*q_d + G(q) -Tau = 0
# C : coriolis force
# G : gravity
# M(q)*q_dd + C(q, q_d)*q_d + G(q) -Tau = 0
# b = C(q, q_d)*q_d + G(q) -Tau
# G = G(q)
# C = b - G = C(q, q_d)*q_d + G(q) - G(q) = C(q, q_d)*q_d
M = EOM.jacobian(q_dd)
b = EOM.subs([
    (theta1_dd, 0),
    (theta2_dd, 0),
])
G = b.subs([
    (theta1_d, 0),
    (theta2_d, 0),
])
C = b - G

print('M11 = ', sy.simplify(M[0, 0]))
print('M12 = ', sy.simplify(M[0, 1]))
print('M21 = ', sy.simplify(M[1, 0]))
print('M22 = ', sy.simplify(M[1, 1]), '\n')

print('C1 = ', sy.simplify(C[0]))
print('C2 = ', sy.simplify(C[1]), '\n')
print('G1 = ', sy.simplify(G[0]))
print('G2 = ', sy.simplify(G[1]), '\n')
```
윗부분은 저번시간에 확인한 sympy를 이용하여 EOM을 구하는 과정이다. 그리고 새로 알아야하는 부분이 M,G,C를 정의하는 부분이다. 먼저 M파트를 뽑아내는 방법은 EOM의 jacobian을 뽑아내면 된다. 그렇게 찾아주고 M파트는 theta_dd만 가지고 있기 때문에 theta_dd파트를 0르로 만들어줘서 b에 저장해준다. 그리고 b에는 C랑 G가 섞여있기 때문에 theta_d에 0을 넣어주어 G를 얻어주게 된다. 그후 b에서 G를 빼주어 C를 얻어줄수 있게 된다. 이 시뮬레이션 결과를 복사 붙여넣기해서 사용하면 된다.       
이 코드를 더 자세하게 보자면!!   
### 코드분해
처음에는 먼저 필요한 symbolic 변수들을 생성한다.   
```python
import sympy as sy

theta1, theta2 = sy.symbols('theta1 theta2', real=True)
m1, m2 = sy.symbols('m1 m2', real=True)
l1, l2 = sy.symbols('l1 l2', real=True)
c1, c2 = sy.symbols('c1 c2', real=True)
I1, I2 = sy.symbols('I1 I2', real=True)
g = sy.symbols('g', real=True)
```
다음은 이러한 sybol들을 이용하여 double pendulum의 각 좌표계 사이 변환을 구하고 world frame에서의 joint 위치를 계산한다.    
```python
# link1 frame to world frame
theta1_ = 3*sy.pi/2 + theta1
H_01 = sy.Matrix([
    [sy.cos(theta1_), -sy.sin(theta1_), 0],
    [sy.sin(theta1_),  sy.cos(theta1_), 0],
    [0, 0, 1]
])

# link2 frame to world frame
H_12 = sy.Matrix([
    [sy.cos(theta2), -sy.sin(theta2), l1],
    [sy.sin(theta2),  sy.cos(theta2), 0],
    [0, 0, 1]
])
H_02 = H_01 * H_12

# c1 in world frame
G1 = H_01 * sy.Matrix([c1, 0, 1])
G1_xy = sy.Matrix([G1[0], G1[1]])

# c2 in world frame
G2 = H_02 * sy.Matrix([c2, 0, 1])
G2_xy = sy.Matrix([G2[0], G2[1]])
```
이렇게 c1과 c2의 위치를 뽑아내고 G1과 G2의 속도를 다음과 같이 뽑아 주어, 운동에너지와 위치에너지, 라그랑지안을 구해준다.    
```cpp
# velocity vectors
theta1_d, theta2_d = sy.symbols('theta1_d theta2_d', real=True)
q = sy.Matrix([theta1, theta2])
q_d = sy.Matrix([theta1_d, theta2_d])

v_G1 = G1_xy.jacobian(q) * q_d
v_G2 = G2_xy.jacobian(q) * q_d

# kinetic energy
T1 = 0.5*m1*v_G1.dot(v_G1) + 0.5*I1*theta1_d**2
T2 = 0.5*m2*v_G2.dot(v_G2) + 0.5*I2*(theta1_d+theta2_d)**2
T = T1 + T2

# potential energy
V1 = m1*g*G1[1]
V2 = m2*g*G2[1]
V = V1 + V2

# Lagrangian
L = T - V
```
이렇게 구한 Lagrangian을 이용하여 E-L Equation을 구해준다.   
```cpp
# Lagrange equation
theta1_dd, theta2_dd = sy.symbols('theta1_dd theta2_dd', real=True)
q_dd = sy.Matrix([theta1_dd, theta2_dd])

dL_dq_d = []
dt_dL_dq_d = []
dL_dq = []
EOM = []

for i in range(len(q)):
    dL_dq_d.append(sy.diff(L, q_d[i]))
    temp = 0
    for j in range(len(q)):
        temp += sy.diff(dL_dq_d[i], q[j]) * q_d[j] + \\
                sy.diff(dL_dq_d[i], q_d[j]) * q_dd[j]
    
    dt_dL_dq_d.append(temp)
    dL_dq.append(sy.diff(L, q[i]))
    # 현재 외력이 0이므로 이 두개 항만 있다.
    EOM.append(dt_dL_dq_d[i] - dL_dq[i])

EOM = sy.Matrix([EOM[0],EOM[1]])
```
이 코드를 분석하면 다음과 같다.   
먼저 []를 통해 변수 및 리스트를 초기화해준다.   
그 후 라그랑지 방정식을 유도해준다. dL_dq_d에 sy.diff(L, q_d[i]를 통해 저장해주고 다음은 시간에 따른 전미분 과정이다. 이 과정에는 체인룰이 적용되어있다.    
temp을 초기화를 진행시켜주고 

그리고 EOM을 정리한후 아까와 같이  M,G,C를 정의해주면 코드가 완성된다.    
