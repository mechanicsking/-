(25.06.28 작성)
# 4강 DD mobile Robot
다양한 형태의 로봇이 존재한다. 그 중 바퀴, 다리를 가진 이동할 수 있는 로봇을 mobile robot이라고 지칭한다.    
이번 장에서는 mobile robot differential drive 타입의 모바일 로봇에 대한 FK와 IK를 학습하고 구현해본다.   
## Differential Drive 모델
로봇청소기같은 로봇을 말한다. 앞뒤로 움직이거나 제자리에서 회전을 한다. but, 양옆으로 움직이는게 불가능하다.   
![image](https://github.com/user-attachments/assets/618a10eb-0b67-453b-a18e-215ed547b62f)    
로봇팔의 경우 theta1,theta2를 통해 end effect의 x,y를 구했었다. DD모델의 경우 선속도 v, 각속도 w를 통해 $(x, y, \theta)$를 구해줄 것이다.   
이번에는 속도제어를 살펴본다.   
![image](https://github.com/user-attachments/assets/bf5f8fd2-ebe6-4218-a071-7cf45b15103e)   
이렇게 식을 얻을 수 있으며 우리가 구할 선속도는 다음과 같이 바퀴의 반지름과 각 바퀴의 각속도를 곱함으로써 얻을 수 있다.   
![image](https://github.com/user-attachments/assets/541dd1ca-1ed7-442e-a042-121c2ad7414a)    
따라서 로봇의 선속도는 다음과 같이 각각 바퀴의 선속도를 더한값의 1/2값이 되게 된다.    
또한 로봇의 각속도는 각각의 바퀴의 선속도의 차이에서 발생하게 된다.   
![image](https://github.com/user-attachments/assets/8ea82a4d-241a-4558-817b-dd43b7c4740e)   
## Forward Kinematic
![image](https://github.com/user-attachments/assets/3264e56f-1a02-4f62-877d-b0ea34933434)   
우리는 이 속도를 Euler integration을 통해 위치를 계산해 줄 것이다.    
![image](https://github.com/user-attachments/assets/8fd07b57-5e4f-4add-8c90-a24f8400ace5)   
t의 위치를 통해 t+1의 위치를 알아낸다. 이를 통해 계속해서 누적 시켜 최종 위치를 알아낸다.    
## 코드 분석
코드는 다음과 같이 구성이 된다.   
1. control signal 준비   
2. Euler Integration을 통한 state 누적 계산   
3. Animation 재생   
### control signal 준비 코드
로봇 입장에서 양쪽 바퀴 각속도를 제어값으로 갖지만, 이번 예시에서는 편의를 위해 2차원 평면에서의 선속도와 각속도를 제어값으로 실행한다.    
```python
def motion_simulation():
  # initial condition, [x0, y0, theta0]
  z0 = [0, 0, -math.pi/2]

  # integration time step

  # %%%%% the controls are v = speed and omega = direction
  # %%%%%% v = 0.5r(phidot_r + phidot_l)
  # %%%%%% omega = 0.5 (r/b)*(phitdot_r - phidot_l)
  # %%%%%% these are set below %%%%%%
  # %%%%%%% writing letters %%%%%%%
  t1 = np.arange(0, 1, 0.1)
  t2 = np.arange(1, 2, 0.1)
  t3 = np.arange(2, 3, 0.1)

  t = np.append(t1, t2)
  t = np.append(t, t3)

  u = np.zeros((len(t), 2))

  for i in range(0, len(t1)):
    u[i, 0] = 1
  for i in range(len(t1), len(t1) + len(t1)):
    u[i, 1] = math.pi/2
    u[i, 0] = 1
  for i in range(len(t1) + len(t2), len(t)):
    u[i, 0] = 1

  z = np. array(z0)

  for i in range(0, len(t)-1):
    z0 = euler_integration(t[i], t[i+1], z0, [u[i, 0], u[i, 1]])
    z =np.vstack([z, z0])

  return t, z
```
 이 코드를 통해 시간을 0초부터 3초까지 속도를 제어할 것이다. for문을 통해 0초-1초는 선속도 1만 주고 1초-2초까지는 선속도 1과 각속도 pi/2를 주게 된다. 마지막으로 2초-3초까지는 선속도 1만 주게 된다. 그리고 이 속도에 관한 정보를 euler_integraion함수에 넘겨주게 된다. 
 ### Euler Integration을 통한 state 누적 계산  
 ```python
def euler_integration(tspan,z0,u):
  v, omega = u
  h = tspan[1] - tspan[0]
  x0, y0, theta0 = z0

  xdot_c = v * math.cos(theta0)
  ydot_c = v * math.sin(theta0)
  thetadot = omega

  x1 = x0 + xdot_c * h
  y1 = y0 + ydot_c * h
  theta1 = theta0 + thetadot * h

  return [x1, y1, theta1]
 ```
Euler Integration을 계산한다. 다음 state인 x, y theta를 얻을 수 있으며, 이를 z라는 리스트에 누적시킨다.
### Animation 재생
 ```python
def animate(t, z):

    R = 0.1

    for i in range(0, len(t)):
        x, y, theta = z[i]

        x2 = x + R*np.cos(theta)
        y2 = y + R*np.sin(theta)

        robot,  = plt.plot(x, y, color='green', marker='o', markersize=15)
        line, = plt.plot([x, x2], [y, y2], color='black')
        shape, = plt.plot(z[0:i, 0], z[0:i, 1], color='red')

        plt.xlim(-2, 2)
        plt.ylim(-2, 2)
        plt.gca().set_aspect('equal')
        plt.pause(0.1)
        line.remove()
        robot.remove()
        shape.remove()
 ```
### 최종 코드
 ```python
import math

from matplotlib import pyplot as plt

import numpy as np


def animate(t, z):

    R = 0.1

    for i in range(0, len(t)):
        x, y, theta = z[i]

        x2 = x + R*np.cos(theta)
        y2 = y + R*np.sin(theta)

        robot,  = plt.plot(x, y, color='green', marker='o', markersize=15)
        line, = plt.plot([x, x2], [y, y2], color='black')
        shape, = plt.plot(z[0:i, 0], z[0:i, 1], color='red')

        plt.xlim(-2, 2)
        plt.ylim(-2, 2)
        plt.gca().set_aspect('equal')
        plt.pause(0.1)
        line.remove()
        robot.remove()
        shape.remove()


def euler_integration(tspan, z0, u):
    v, omega = u
    h = tspan[1] - tspan[0]
    x0, y0, theta0 = z0

    xdot_c = v * math.cos(theta0)
    ydot_c = v * math.sin(theta0)
    thetadot = omega

    x1 = x0 + xdot_c * h
    y1 = y0 + ydot_c * h
    theta1 = theta0 + thetadot * h

    return [x1, y1, theta1]


def motion_simulation():
    # initial condition, [x0, y0, theta0]
    z0 = [0, 0, -math.pi/2]

    # integration time step

    # %%%%% the controls are v = speed and omega = direction
    # %%%%%% v = 0.5r(phidot_r + phidot_l)
    # %%%%%% omega = 0.5 (r/b)*(phitdot_r - phidot_l)
    # %%%%%% these are set below %%%%%%
    # %%%%%%% writing letters %%%%%%%
    t1 = np.arange(0, 1, 0.1)
    t2 = np.arange(1, 2, 0.1)
    t3 = np.arange(2, 3, 0.1)

    t = np.append(t1, t2)
    t = np.append(t, t3)

    u = np.zeros((len(t), 2))

    for i in range(0, len(t1)):
        u[i, 0] = 1
    for i in range(len(t1), len(t1) + len(t1)):
        u[i, 1] = math.pi/2
        u[i, 0] = 1
    for i in range(len(t1) + len(t2), len(t)):
        u[i, 0] = 1

    z = np.array(z0)

    for i in range(0, len(t)-1):
        z0 = euler_integration([t[i], t[i+1]], z0, [u[i, 0], u[i, 1]])
        z = np.vstack([z, z0])

    return t, z


if __name__ == '__main__':

    try:
        timestamps, precalculated_state = motion_simulation()
        animate(timestamps, precalculated_state)
    except Exception as e:
        print(e)
    finally:
        plt.close()
 ```
try-except-finally 블록, 오류 처리 및 리소스 관리를 위한 표준 구조   
try부분을 실행하다가 오류가 나면 except 예외처리를 해서 print(e)를 통해 오류메세지를 출력하고, finally블록을 통해 리소스를 정리한다. 이 코드에서는 Matplotlib 창 강제 종료한다.    
## Inverse Kinematic
### Robot movement in world frame
먼저 homogeneous matrix를 복습한다.   
![image](https://github.com/user-attachments/assets/bbe9d772-a571-4f26-8c3c-6195634ad8fe)   
DD 모바일 로봇은 계속해서 좌표계가 바뀌게 된다. 따라서 로봇 입장에서의 움직임을 world frame에서의 움직임으로 계속 바꿔가면서 누적해줘야한다.   
![image](https://github.com/user-attachments/assets/30f95718-4cb8-49eb-ba1c-2ed382a3fafa)   
## 이론
input--> 현재 로봇의 state $(x, y, \theta)$ 와 로봇이 이동하기 원하는 $(x_[ref], y_ref)$

