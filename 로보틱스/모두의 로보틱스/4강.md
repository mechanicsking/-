(25.06.28 작성)
# 4강 DD mobile Robot
다양한 형태의 로봇이 존재한다. 그 중 바퀴, 다리를 가진 이동할 수 있는 로봇을 mobile robot이라고 지칭한다.    
이번 장에서는 mobile robot differential drive 타입의 모바일 로봇에 대한 FK와 IK를 학습하고 구현해본다.   
## Differential Drive 모델
로봇청소기같은 로봇을 말한다. 앞뒤로 움직이거나 제자리에서 회전을 한다. but, 양옆으로 움직이는게 불가능하다.   
![image](https://github.com/user-attachments/assets/618a10eb-0b67-453b-a18e-215ed547b62f)    
로봇팔의 경우 theta1,theta2를 통해 end effect의 x,y를 구했었다. DD모델의 경우 선속도 v, 각속도 w를 통해 $(x, y, \theta)$를 구해줄 것이다.   
이번에는 속도제어를 살펴본다.   
![image](https://github.com/user-attachments/assets/bf5f8fd2-ebe6-4218-a071-7cf45b15103e)   
이렇게 식을 얻을 수 있으며 우리가 구할 선속도는 다음과 같이 바퀴의 반지름과 각 바퀴의 각속도를 곱함으로써 얻을 수 있다.   
![image](https://github.com/user-attachments/assets/541dd1ca-1ed7-442e-a042-121c2ad7414a)    
따라서 로봇의 선속도는 다음과 같이 각각 바퀴의 선속도를 더한값의 1/2값이 되게 된다.    
또한 로봇의 각속도는 각각의 바퀴의 선속도의 차이에서 발생하게 된다.   
![image](https://github.com/user-attachments/assets/8ea82a4d-241a-4558-817b-dd43b7c4740e)   
## Forward Kinematic
![image](https://github.com/user-attachments/assets/3264e56f-1a02-4f62-877d-b0ea34933434)   
우리는 이 속도를 Euler integration을 통해 위치를 계산해 줄 것이다.    
![image](https://github.com/user-attachments/assets/8fd07b57-5e4f-4add-8c90-a24f8400ace5)   
t의 위치를 통해 t+1의 위치를 알아낸다. 이를 통해 계속해서 누적 시켜 최종 위치를 알아낸다.    
## 코드 분석
코드는 다음과 같이 구성이 된다.   
1. control signal 준비   
2. Euler Integration을 통한 state 누적 계산   
3. Animation 재생   
### control signal 준비 코드
로봇 입장에서 양쪽 바퀴 각속도를 제어값으로 갖지만, 이번 예시에서는 편의를 위해 2차원 평면에서의 선속도와 각속도를 제어값으로 실행한다.    
```python
def motion_simulation():
  # initial condition, [x0, y0, theta0]
  z0 = [0, 0, -math.pi/2]

  # integration time step

  # %%%%% the controls are v = speed and omega = direction
  # %%%%%% v = 0.5r(phidot_r + phidot_l)
  # %%%%%% omega = 0.5 (r/b)*(phitdot_r - phidot_l)
  # %%%%%% these are set below %%%%%%
  # %%%%%%% writing letters %%%%%%%
  t1 = np.arange(0, 1, 0.1)
  t2 = np.arange(1, 2, 0.1)
  t3 = np.arange(2, 3, 0.1)

  t = np.append(t1, t2)
  t = np.append(t, t3)

  u = np.zeros((len(t), 2))

  for i in range(0, len(t1)):
    u[i, 0] = 1
  for i in range(len(t1), len(t1) + len(t1)):
    u[i, 1] = math.pi/2
    u[i, 0] = 1
  for i in range(len(t1) + len(t2), len(t)):
    u[i, 0] = 1

  z = np. array(z0)

  for i in range(0, len(t)-1):
    z0 = euler_integration(t[i], t[i+1], z0, [u[i, 0], u[i, 1]])
    z =np.vstack([z, z0])

  return t, z
```
 이 코드를 통해 시간을 0초부터 3초까지 속도를 제어할 것이다. for문을 통해 0초~1초는 선속도 1만 주고 1초~2초까지는 선속도 1과 각속도 pi/2를 주게 된다. 마지막으로 2초~3초까지는 선속도 1만 주게 된다. 그리고 이 속도에 관한 정보를 euler_integraion함수에 넘겨주게 된다. 
 ### Euler Integration을 통한 state 누적 계산  
 ```python
def euler_integration(tspan,z0,u):
  v, omega = u
  h = tspan[1] - tspan[0]
  x0, y0, theta0 = z0

  xdot_c = v * math.cos(theta0)
  ydot_c = v * math.sin(theta0)
  thetadot = omega

  x1 = x0 + xdot_c * h
  y1 = y0 + ydot_c * h
  theta1 = theta0 + thetadot * h

  return [x1, y1, theta1]
 ```
