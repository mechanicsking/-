# Creating a package
* 목표: CMake 또는 Python을 사용하여 새로운 패키지를 만들고 만든 패키지의 executable(실행파일)을 실행한다. 

## Background
### 1. What is a ROS 2 package?
패키지는 당신의 ros2 코드에서 조직 단위이다. 만약 당신의 코드를 install하거나 다른사람에게 공유하고 싶을때, 패키지에서 organized할 필요가 있다. 패키지를 사용하면, ros2 work를 배포할 수 있고 다른사람이 build하거나 사용하기 쉽게해준다. ros2에서 패키지를 만들때 ament 빌드 시스템과 colcon 빌드 도구를 사용한다. 패키지는 공식적으로 지원되는 CMake나 Python 방식으로 만들 수 있다. 다른 빌드 타입도 있지만 주로 이 두가지를 사용한다.     
### 2. What makes up a ROS 2 package?
ROS 2 파이썬과 CMake 패키지는 각각 자체적으로 필요한 최소 콘텐츠를 갖고 있다.    
```
CMake로 만드는 경우
- CMakeLists.txt 파일이 필요하다. 이 파일은 패키지내 코드를 어떻게 빌드할 것인지에 대한 설명을 담고 있다. 
- include/<package_name> 경로를 갖는다. 이 경로에는 패키지를 위한 public header파일들이 있다. 
- pakcage.xml 파일이 필요하다. 이 파일은 package와 관련된 meta 정보를 갖는데 이는 필요한 의존성을 갖는 패키지이름등을 포함한다. 
- src경로를 갖는다. 이 경로에는 package의 source code가 담겨있다. 
```
```
Python로 만드는 경우
- pakcage.xml 파일이 필요하다. 이 파일은 package와 관련된 meta 정보를 갖는데 이는 필요한 의존성을 갖는 패키지이름등을 포함한다.  
- resource/<package_name> 마커 파일을 갖는다. 
- setup.cfg 가 필요한데 ros2 run 명령어가 패키지의 executable를 찾는데 도움을 준다. 
- setup.py 가 필요하다. 이 python파일은 pakcage를 어떻게 설치할 것인지에 대한 설치 방법이 포함되어 있다. 
- <package_name> 패키지와 같은 이름을 갖는 폴더이다. ROS2 tool을 이용하여 package를 찾는데 사용된다. __init__.py를 포함하고 있다. 
```
가장 간단한 파일구조는 각각 다음과 같다.    
* CMake의 경우
  ```
  my_package/
       CMakeLists.txt
       include/my_package/
       package.xml
       src/
  ```
* Python의 경우
    ```
    my_package/
        package.xml
        resource/my_package
        setup.cfg
        setup.py
        my_package/
    ```

### 3. Packages in a workspace
하나의 워크스페이스에는 사용자가 원하는만큼  많은 패키지를 넣을 수 있다. 이때 각 패키지는 별도의 폴더에 위치한다. 또한 하나의 워크스페이스에 서로 다른 빌드 타입의 패키지를 가질 수 있다. (CMake, Python,등) 패키지 폴더 안에 또 다른 패키지를 넣는 구조 (중첩)은 불가능하며,  , 각 패키지는 src에서 독립적으로 존재해야 한다. src 폴더 아래에만 패키지를 만들면 빌드 시스템에서 패키지 탐색이 용이하고 관리가 쉬우며, 최상위(workspace 폴더)가 정돈된다. 아래 예시처럼 되는 것이 이상적인 ROS2 워크스페이스 구조이다:
```
workspace_folder/
    src/
      cpp_package_1/
          CMakeLists.txt
          include/cpp_package_1/
          package.xml
          src/

      py_package_1/
          package.xml
          resource/py_package_1
          setup.cfg
          setup.py
          py_package_1/
      ...
      cpp_package_n/
          CMakeLists.txt
          include/cpp_package_n/
          package.xml
          src/
```
## Tasks
### 1. Create a package
먼저 ROS2의 기본 workspace를 소스한다.  
```
source /opt/ros/humble/setup.bash
```
새로운 패키지를 만들기 위해 저번시간에 만든 ros2_ws/src로 이동한다. 패키지 생성 명령을 실행하기 전에 src 폴더에 있는지 확인해야한다. 
```
cd ~/ros2_ws/src
```
ros2에서 새로운 패키지를 만들기 위해서 다음의 커멘드 문법을 사용한다.       
* CMake의 경우
  ```
  $ros2 pkg create --build-type ament_cmake --license Apache-2.0 <package_name>
  ```
  이 튜토리얼에서는 옵션인 --node-name을 사용한다. 이는 Hello World 실행 파일(노드)도 같이 만들어 준다.
  ```
  $ros2 pkg create --build-type ament_cmake --license Apache-2.0 --node-name my_node my_package
  ```
  해당 문법에서의 옵션의 의미는 다음과 같다.       
  --build-type ament_cmake: CMake(주로 C++) 빌드 타입을 사용, --license Apache-2.0: 라이선스 지정, --node-name my_node: Hello World 실행 파일(노드)도 같이 만들어 줌, _package: 생성할 패키지 이름.
* Python의 경우
  ```
  $ros2 pkg create --build-type ament_python --license Apache-2.0 <package_name>
  ```
  ```
  $ros2 pkg create --build-type ament_python --license Apache-2.0 --node-name my_node my_package
  ```

작업공간의 src폴더에 들어가면 my_package라는 폴더가 생성된것을 볼 수 있다. 패키지를 생성하는 명령어를 입력했을 때 다음과 같은 메세지가 터미널에 출력될 것이다.     
* CMake의 경우
  ```
  going to create a new package
  package name: my_package
  destination directory: /home/user/ros2_ws/src
  package format: 3
  version: 0.0.0
  description: TODO: Package description
  maintainer: ['<name> <email>']
  licenses: ['TODO: License declaration']
  build type: ament_cmake
  dependencies: []
  node_name: my_node
  creating folder ./my_package
  creating ./my_package/package.xml
  creating source and include folder
  creating folder ./my_package/src
  creating folder ./my_package/include/my_package
  creating ./my_package/CMakeLists.txt
  creating ./my_package/src/my_node.cpp
  ```
* Python의 경우
  ```
  going to create a new package
  package name: my_package
  destination directory: /home/user/ros2_ws/src
  package format: 3
  version: 0.0.0
  description: TODO: Package description
  maintainer: ['<name> <email>']
  licenses: ['TODO: License declaration']
  build type: ament_python
  dependencies: []
  node_name: my_node
  creating folder ./my_package
  creating ./my_package/package.xml
  creating source folder
  creating folder ./my_package/my_package
  creating ./my_package/setup.py
  creating ./my_package/setup.cfg
  creating folder ./my_package/resource
  creating ./my_package/resource/my_package
  creating ./my_package/my_package/__init__.py
  creating folder ./my_package/test
  creating ./my_package/test/test_copyright.py
  creating ./my_package/test/test_flake8.py
  creating ./my_package/test/test_pep257.py
  creating ./my_package/my_package/my_node.py
  ```

log 메세지에 따르면 여러 파일들이 패키지 생성 명령어가 실행되면서 생성된 것을 확인 할 수 있다.
### 2. Build a package
워크스페이스에 패키지를 넣어놓으면 패키지가 여러개 있더라도 colcon build를 이용해서 한번에 빌드할 수 있는 장점이 있다. 그렇지 않으면 각 패키지를 개별적으로 빌드해야한다.     
워크스페이스에 다시 돌아간다. 
```
$cd ~/ros2_ws
```

저번에 했던 것과 같이 빌드해보자.     
```
$colcon build
```
지난 튜토리얼에서처럼 ros2_ws 워크스페이스 안에 ros_tutorials 패키지들도 같이 들어 있었다. 그래서 터미널에서 colcon build 명령을 실행하면, 내가 원하는 my_package뿐만 아니라 turtlesim 같은 다른 패키지들도 함께 빌드된다. 패키지가 몇 개 없을 때는 괜찮지만, 워크스페이스에 패키지가 많으면 빌드 시간이 길어진다.그래서, 특정 패키지만 빌드하려면 아래처럼 명령어를 쓰면 된다. 아래는 my_packge 패키지만 빌드하는 명령어이다. 
```
$colcon build --packages-select my_package
```
### 3. Source the setup file
새로운 패키지의 실행파일을 실행하기 위해서, 면저 새로운 터미널을 열어 main Ros2 installation(언더레이)를 실행한다. 그리고 ros2_ws디렉토리 안에서 다음의 커멘드를 실행하여 워크스페이스를 소스한다. 
```
$source install/local_setup.bash
```
이제 워크스페이스는 경로를 추가하였고, 새로운 패키지의 실행파일을 사용 가능하다. 
### 4. Use the package
패키지 생성 중에 --node-name 인수를 사용하여 생성한 실행 파일을 실행하려면 다음 커멘드를 입력한다.   
```
$ros2 run my_package my_node
```
그렇다면 터미널에서 다음과 같은 메시지를 받을 수 잇다. 
* CMake
  ```
  hello world my_package package
  ```
  <img width="362" height="58" alt="image" src="https://github.com/user-attachments/assets/e00d1d24-071d-4800-bfb6-6a8e1ead1ac5" />
* Python
  ```
  Hi from my_package.
  ```

### 5. Examine package contents
ros2_ws/src/my_package에서, ros2 pkg create가 자동으로 생성한 파일과 폴더를 볼 수 있다. 
* CMake
  ```
  CMakeLists.txt  include  package.xml  src
  ```
  <img width="362" height="58" alt="image" src="https://github.com/user-attachments/assets/1cb49709-aa8b-4354-ba18-ffa2d412472a" />
  주목할 점은 여기 src폴더 안에 my_node.cpp가 위치한다. 이 src폴더는 앞으로 우리가 작성할 custom C++ node들이 위치할 공간이다.

* Python
  ```
  my_package  package.xml  resource  setup.cfg  setup.py  test
  ```
  비슷하게 my_node.py는 my_package안에 위치한다. 이 패키지 이름과 같은 폴더의 경로에 앞으로 우리가 작성할 custom python node들이 위치할 것이다.

### 6. Customize package.xml
패키지 생성 후 터미널에서 반환되는 메시지에 보면, description(설명)과 license(라이선스) 항목에 “TODO”가 들어가 있다. 그 이유는 이 필드들이 자동으로 완성되지 않고, 나중에 꼭 직접 입력해줘야 하며, 실제 패키지를 릴리즈할 때는 반드시 필요하다. maintainer(관리자)의 이름과 이메일 정보도 비어 있는 경우 꼭 작성해야 한다. 그러니 ros2_ws/src/my_package 폴더에서 좋아하는 텍스트 에디터(vim, nano, VSCode 등)로 package.xml 파일을 열어, description, license, maintainer 같은 항목을 직접 채워달라는 안내이다.
```
$cd ~/ros2_ws/src/my_package
$gedit package.xml
```
* CMake
  ```
  <?xml version="1.0"?>
  <?xml-model
     href="http://download.ros.org/schema/package_format3.xsd"
     schematypens="http://www.w3.org/2001/XMLSchema"?>
  <package format="3">
   <name>my_package</name>
   <version>0.0.0</version>
   <description>TODO: Package description</description>
   <maintainer email="user@todo.todo">user</maintainer>
   <license>TODO: License declaration</license>
  
   <buildtool_depend>ament_cmake</buildtool_depend>
  
   <test_depend>ament_lint_auto</test_depend>
   <test_depend>ament_lint_common</test_depend>
  
   <export>
     <build_type>ament_cmake</build_type>
   </export>
  </package>
  ```
* Python
  ```
  <?xml version="1.0"?>
  <?xml-model
     href="http://download.ros.org/schema/package_format3.xsd"
     schematypens="http://www.w3.org/2001/XMLSchema"?>
  <package format="3">
   <name>my_package</name>
   <version>0.0.0</version>
   <description>TODO: Package description</description>
   <maintainer email="user@todo.todo">user</maintainer>
   <license>TODO: License declaration</license>
  
   <test_depend>ament_copyright</test_depend>
   <test_depend>ament_flake8</test_depend>
   <test_depend>ament_pep257</test_depend>
   <test_depend>python3-pytest</test_depend>
  
   <export>
     <build_type>ament_python</build_type>
   </export>
  </package>
  ```

자동으로 채워지지 않을 경우 maintiner 라인에 이름과 이메일을 입력한다. 그런 다음 description라인을 편집하여 패키지를 요약한다. 
```
<description>Beginner client libraries tutorials practice package</description>
```
그리고 license라인도 업데이트한다. 오픈소스 라이센스를 확인하고 싶다면 (https://opensource.org/license) 를 참고한다. 이번 패키지는 연습을 위한것이기에 아무 라이센스를 사용해도 안전하다. 우리는 Apache License 2.0를 사용할 것이다.   
```
<license>Apache License 2.0</license>
```
편집이 끝나면 저장하는 것을 잊지마라    
<img width="874" height="352" alt="image" src="https://github.com/user-attachments/assets/8e49c5c6-efd9-449c-a382-2f6f3a1677af" />     

package.xml 파일에는 이 패키지가 빌드되고 실행되기 위해 필요한 다른 패키지들을 명시하는 태그들이 있습니다. 이 태그들은 <depend>, <build_depend>, <exec_depend> 등으로 끝에 _depend가 붙는다. colcon 빌드 도구는 이 의존성 정보를 보고 필요한 다른 패키지들을 자동으로 찾아서 함께 빌드하거나 준비한다. 예제로 든 my_package는 아직 의존성이 없지만, 앞으로의 튜토리얼을 진행하며 이 부분을 실제로 작성하고 사용하게 될 것이다.패키지 의존성 관리는 rosdep이라는 도구와 함께 연결되어 있어서, 시스템에서 필요한 라이브러리도 자동 설치될 수 있게 돕는다.     
Python으로 생성한 경우 한가지 작업을 더해줘야 하는데 바로 setup.py에서 우리가 package.xml에서 수정한 부분에 해당하는 곳을 변경하는 일이다. 먼저 setup.py를 편집기로 열어준다.    
```
$cd ~/ros2_ws/src/my_package
$gedit setup.py
```
```
from setuptools import setup

package_name = 'my_py_pkg'

setup(
 name=package_name,
 version='0.0.0',
 packages=[package_name],
 data_files=[
     ('share/ament_index/resource_index/packages',
             ['resource/' + package_name]),
     ('share/' + package_name, ['package.xml']),
   ],
 install_requires=['setuptools'],
 zip_safe=True,
 maintainer='TODO',
 maintainer_email='TODO',
 description='TODO: Package description',
 license='TODO: License declaration',
 tests_require=['pytest'],
 entry_points={
     'console_scripts': [
             'my_node = my_py_pkg.my_node:main'
     ],
   },
)
```
여기서 아까 위에서 description, license, maintainer, maintainer이름을 package.xml에서 변경한대로 바꿔준다.

## Summary
코드를 정리하고 다른 사람이 사용하기 쉽게 하기 위해 패키지를 만들었다. 패키지를 만들면 필요한 파일들이 자동으로 생성되고, 그 후에 colcon을 사용해 패키지를 빌드하여 로컬 환경에서 실행 파일을 사용할 수 있게 되었다.
