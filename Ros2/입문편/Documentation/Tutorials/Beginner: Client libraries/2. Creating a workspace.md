# Creating a workspace
* 목표: workspace를 만들고 개발 및 테스트를 위한 overlay 설정 방법을 배운다.

## Background
workspace는 ros2 패키지를 담고있는 디렉토리이다. ros2를 사용하기 전에 작업하려는 터미널 세션에서 ROS 2가 설치된 워크스페이스 환경을 로드(소스) 해야 한다(ex. source /opt/ros/humble/setup.bash) 이것은 ros2패키지를 터미널에서 사용할 수 있게 만들어준다.     
ROS 2에서는 기본 설치된 워크스페이스(underlay)에 덧붙여서, 새로운 패키지를 추가하거나 수정할 수 있는 “오버레이(overlay)” 워크스페이스를 만들 수 있다. 오버레이는 기존 워크스페이스에 영향을 주지 않고 별도로 작업할 수 있는 공간이다.오버레이가 제대로 작동하려면,오버레이 내 모든 패키지의 의존성은 반드시 기본 워크스페이스(underlay) 안에 있어야 한다. 오버레이에 있는 패키지가 underlay에 있는 동일한 패키지보다 우선권을 갖게 되어, 오버레이의 패키지가 언더레이의 패키지를 덮어쓰기(override) 된다. 또한 오버레이와 언더레이를 여러 단계로 쌓아서(여러 겹 만들어서) 상위 오버레이는 바로 아래 언더레이의 패키지를 사용할 수 있게 할 수도 있다.
## Task
### 1. Source ROS2 environment
이 튜토리얼에서는 기본적으로 메인 ROS 2 설치가 언더레이(underlay) 역할을 한다.(하지만 꼭 메인 ROS 2 설치만이 언더레이가 되어야 하는 것은 아니다.) ROS 2를 설치한 방법(소스 빌드인지 바이너리 설치인지)과 사용하는 운영 체제에 따라,ROS 2 환경을 활성화하는 source 명령어는 약간씩 다를 수 있다. 해당 튜토리얼에서는 linux를 기준으로 작성하겟다.
```
$source /opt/ros/humble/setup.bash
```
### 2. Create a new directory
새로운 한 워크스페이스를 위해 하나의 디렉토리를 만드는 것이 좋은 방법이다. 이름은 아무 상관없지만, 디렉토리의 목적을 표시하는 것이 도움이 된다. 디렉토리의 이름을 워크스페이스 개발을 위해 ros2_ws로 정하자. 
```
$mkdir -p ~/ros2_ws/src
$cd ~/ros2_ws/src
```
이전 튜토리얼에서 만들엇다면 만들지 않아도 된다. 또 다른 좋은 습관(beset practice)은, 워크스페이스 안에 있는 모든 ROS 2 패키지는 src 폴더 안에 넣는 것이다. 예시로 제공된 명령어는 ros2_ws라는 워크스페이스 디렉토리 안에 src 폴더를 생성하고, 그 폴더로 이동하는 작업을 수행한다.
### 3. Clone a sample repo
현재 위치가 ros2_ws/src 디렉토리인지 꼭 확인해야한다. 아직은 직접 패키지를 만들지 않고, 기존에 만들어진 패키지를 이용해 워크스페이스 구성을 연습할 것이다. turtlesim 패키지가 포함된 ros_tutorials라는 저장소(repo)를 클론(clone)하려면, ros2_ws/src 폴더 안에서 아래 명령어를 실행한다:
```
$git clone https://github.com/ros/ros_tutorials.git -b humble
```
여기서 -b humble 옵션은 설치된 ROS 2 버전인 humble 브랜치를 체크아웃하겠다는 뜻이다. 이제 ros_tutorials 저장소가 워크스페이스에 복사(clone)되었다. 이 저장소에는 turtlesim 같은 패키지가 포함되어 있으며, 이번 튜토리얼에 사용할 예정이다. 저장소 내 다른 패키지들은 COLCON_IGNORE 파일이 있어 빌드 대상에서 제외된다. 현재는 예제 패키지를 워크스페이스에 넣은 상태이며,아직 완전한 워크스페이스가 아니다. 그 이유는 먼저 패키지 의존성을 해결하고 나서 빌드해야 하기 때문이다.   
### 4. Resolve dependencies
워크스페이스를 만들기 전에, 패키지의 의존성을 해결해야한다. 이미 필요한 의존성이 모두 있을 수도 있지만, 새로운 저장소를 클론(clone)할 때마다 의존성을 꼭 확인하는 것이 좋은 습관이다. 왜냐하면, 빌드 시간이 오래 걸린 후에 누락된 의존성 때문에 실패하는 상황을 막기 위해서이다.       
ros2_ws 워크스페이스의 최상위 디렉토리(루트)에서 아래의 명령어를 실행해라. 만약 아직 src 디렉토리에서 작업 중이면, cd ..를 실행하여 워크스페이스 루트로 이동해야한다는 의미이다. 
```
$cd ..
$rosdep install -i --from-path src --rosdistro humble -y
```
이 명령어는 워크스페이스 내 src 폴더에서 패키지들의 package.xml 파일을 찾아서 필요한 의존성을 설치해준다. (rosdep의 특징) 만약 모든 의존성이 이미 설치되어 있으면, 다음과 같은 메시지가 콘솔에 출력된다.   

```
#All required rosdeps installed successfully
```
<img width="717" height="50" alt="image" src="https://github.com/user-attachments/assets/3f3c7593-d929-4c18-8f6c-1fd0656032ec" />       

패키지들은 package.xml 파일에서 의존성을 선언하며,rosdep은 이 파일을 참고해 필요한 패키지를 자동으로 찾아서 설치한다. 더 자세한 rosdep 사용법은 추후 튜토리얼에서 배울 수 있다. (간단히 rosdep 명령어의 동작원리를 설명하자면 ros2 package는 package.xml이라는 파일을 포함하고 있는데 rosdep 명령어는 이 파일에 명시된 dependency들을 확인하고 아직 설치되어있지 않다면 설치한다.)     
### 5. Build the workspace with colcon
ros2_ws 워크스페이스의 디렉토리에서 다음 커멘드를 사용하여 패키지를 빌드할 수 있다.          
```
$colcon build
Starting >>> turtlesim
Finished <<< turtlesim [5.49s]

Summary: 1 package finished [5.58s]
```
현재 작성자는 이전 튜토리얼도 진행햇기에 23개의 패키지가 빌드되엇음을 확인할 수 잇다.    
<img width="722" height="170" alt="image" src="https://github.com/user-attachments/assets/5f0c0673-68f8-4d6d-98b0-6ff665265b14" />     

**NOTE!**- 다른 유용한 colcon build 명령어 옵션들
* --packages-up-to 는 원하는 패키지와 그 패키지가 의존하는 모든 패키지를 빌드한다. 전체 워크스페이스를 빌드하지 않아 시간을 절약할 수 있다.
  <img width="721" height="104" alt="image" src="https://github.com/user-attachments/assets/498c214b-378e-4942-8651-c4b839ecbc76" />
  잘 작동되는 모습을 확인할 수 있다.
* --symlink-install 은 파이썬 스크립트를 조금 수정할 때마다 매번 재빌드하지 않아도 된다. 실제 파일 복사 대신 심볼릭 링크를 만들기 때문이다.
* --event-handlers console_direct+는 빌드하는 동안 콘솔에 자세한 출력 내용을 보여준다. 출력 내용은 기본적으로 로그 디렉토리에 저장된다.
* --executor sequential는 여러 패키지를 병렬로 빌드하지 않고, 순차적으로 하나씩 빌드한다.

빌드가 끝나면, 워크스페이스 루트(~/ros2_ws)로 이동 후 명령어를 입력해본다. 빌드가 완료되면 colcon이 다음과 같은 새 디렉토리들을 생성하는 것을 확인해 볼 수 있다.:
```
$ls
build  install  log  src
```
<img width="504" height="43" alt="image" src="https://github.com/user-attachments/assets/dd7f5cdb-eaab-41de-8dbd-55fc4dc6f2d9" />      

install 디렉토리는 워크스페이스의 설정 파일이 있는 곳으로, 오버레이를 source하는데 사용할 수 있다. 
### 6. Source the overlay
워크스페이스의 오버레이(overlay)를 소스(환경 설정)하기 전에, 워크스페이스를 빌드한 터미널과는 별도의 **새 터미널**을 열어야 한다. 같은 터미널에서 오버레이를 소스한 상태로 빌드하거나,빌드한 터미널에서 다시 오버레이를 소스하면 복잡한 문제가 발생할 수 있다.      
새 터미널에서 먼저 메인 ros2 환경(underlay)를 소스한다. 즉, 기존 설치된 ros2가 제공하는 기본 환경을 로드하는 것이다.이로써 오버레이를 그 위에 쌓아 올릴 준비를 한다.    
```
$source /opt/ros/humble/setup.bash
```
언더레이를 소스하고 워크스페이스의 디렉토리로 들어가준다.   
```
$cd ~/ros2_ws
```
이 디렉토리에서 당신의 오버레이 워크스페이스 환경을 소스해준다.  
```
$source install/local_setup.bash
```
**NOTE!**- 오버레이의 local_setup.bash를 소스하면 오버레이 내에 있는 패키지만 현재 환경에 추가된다. 반면, setup.bash는 오버레이와 그 오버레이가 바탕으로 하는 언더레이(underlay) 둘 다 환경에 추가한다. 그래서 메인 ROS 2 설치의 setup.bash를 소스한 뒤에,
오버레이 워크스페이스의 local_setup.bash를 소스하는 것은 오버레이의 setup.bash를 소스하는 것과 동일하다. 그 이유는 오버레이의 setup.bash가 언더레이 환경까지 포함하여 설정하기 때문이다.          

이제 오버레이에 있는 turtlesim 패키지를 실행할 수 있다.   
```
$ros2 run turtlesim turtlesim_node
```
하지만 이 turtlesim이 오버레이의 것인지 언더레이의 것인지 구분하려면 어떻게 해야할까?? 오버레이의 turtlesim이 실행되었다면 다음과 같은 효과를 확인할 수 있다.   
* 오버레이에선 언더레이와 별도로 패키지를 수정하고 재구성할 수 있다.
* 오버레이는 언더레이보다 우선권을 가진다.

즉, 오버레이 내 패키지 수정 및 빌드가 메인 설치에 영향을 주지 않고 반영된다. 그렇기 때문에 overlay에 있는 turtlesim을 조금 변형시켜서 변화가 일어나면 overlay의 turtlesim이라는 것을 알 수 있다. 
### 7. Modify the overlay
오버레이 워크스페이스에서 turtlesim을 수정하려면, turtlesim 창의 제목 표시줄을 변경해 볼 수 있다. 
1. ~/ros2_ws/src/ros_tutorials/turtlesim/src 경로에 있는turtle_frame.cpp 파일을 연다. (선호하는 텍스트 편집기로 열면 된다.)
2. setWindowTitle("TurtleSim"); 라는 함수 호출을 찾는다.
3. "TurtleSim" 문자열을 "MyTurtleSim" 으로 변경하고 파일을 저장한다.
4. 이전에 colcon build 명령을 실행했던 첫 번째 터미널로 돌아가서, 다시 colcon build 명령을 실행해 빌드한다.
5. 두 번째 터미널(오버레이가 소스된)로 가서, 다음 명령어로 turtlesim을 실행한다.:

<img width="612" height="54" alt="image" src="https://github.com/user-attachments/assets/b491d411-2c71-4bab-8f29-875fb6b3bf87" />      

```
$nano turtle_frame.cpp
```
이 명령어를 통해 열어준다. 
<img width="366" height="333" alt="image" src="https://github.com/user-attachments/assets/399ab70a-796f-410c-86da-ba6c075e4c0a" />      

<img width="366" height="333" alt="image" src="https://github.com/user-attachments/assets/20c584c9-ebad-4f9b-a234-353d5f20ca82" />        

ctrl+o를 통해 저장하고 ctrl+x를 통해 나간다.       
이후 첫번째 터미널로 돌아가서 colcon build 실행한다.   
<img width="729" height="138" alt="image" src="https://github.com/user-attachments/assets/dea32931-3840-444a-a4c1-8e7bf4a1744d" />        
다시 두번째 터미널에 돌아와서(오버레이가 소스된 위치) turtlesim 을 다시 실행해준다.    
```
$ros2 run turtlesim turtlesim_node
```
turtlesim 윈도우에 제목바의 이름이 “MyTurtleSim”이 된것을 확인할 수 있다.   
<img width="498" height="531" alt="image" src="https://github.com/user-attachments/assets/a71822e0-8958-4324-8bae-33e860658579" />     

비록 이 터미널에서 메인 ros2환경(언더레이)을 먼저 소스했지만, 아까 언급했듯이 ros2_ws 오버레이가 언더레이 내용보다 우선한다. 언더레이가 여전히 정상적으로 유지되고 있는지 확인하려면, 새로운 터미널을 열고 언더레이 환경만 소스한뒤 다시 turtleaim을 실행해본다.    
```
$ros2 run turtlesim turtlesim_node
```
<img width="498" height="531" alt="image" src="https://github.com/user-attachments/assets/ea19384e-41cd-459e-88e6-20ca6a1b26b5" />          

이때보면, 오버레이에서 한 수정은 언더레이에 전혀 영향을 주지 않았다는 것을 알 수 있다.     
## Summary
이 튜토리얼에서는 메인 ROS 2 설치를 언더레이(underlay)로 소스하고,새로운 워크스페이스를 만들어 오버레이(overlay)를 생성했다.오버레이는 시스템 경로에서 언더레이보다 앞에 추가되어 우선권을 가진다.이것은 수정한 turtlesim 패키지에서 확인할 수 있었다.     
오버레이 워크스페이스 사용은 소수의 패키지를 작업할 때 권장된다. 그렇지 않으면 모든 패키지를 한 워크스페이스에 넣고,매번 전체 워크스페이스를 다시 빌드해야 하기 때문이다. 쉽게 말해,작은 단위로 나눠서 작업하고 빠르게 테스트하는 데 오버레이가 유리하다. 
