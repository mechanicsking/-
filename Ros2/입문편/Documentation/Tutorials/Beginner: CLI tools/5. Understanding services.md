(25.08.27작성)
# Understanding services
* 목표: 명령줄 도구를 이용하여 ros2의 services를 배워보자.

## Background
서비스는 ros graph에서 노드들끼리 의사소통을 하는 또다른 방식이다. 서비스는 토픽에서의 publisher-subscriber모델과 대비되는 call-and-response모델을 기반으로 둔다. 토픽은 노드가 데이터 스트림을 subscribe하고 지속적인 업데이트를 받을 수 잇게 해주지만, 서비스는 client가 특별히 호출할 때만 데이터를 제공한다.       
<img width="854" height="480" alt="image" src="https://github.com/user-attachments/assets/b04ccf71-1ceb-4fba-8929-9c6d0e65b69b" />      

<img width="854" height="480" alt="image" src="https://github.com/user-attachments/assets/75336c2b-e320-4e61-acf4-cc66205fd676" />       

## Prerequisites
이번 튜토리얼에서는 노드와 토픽라는 개념을 끌고 가기 때문에 이를 숙지해야한다.    
## Tasks
### 1. Setup
/turtlesim과 /teleop_turtle 두 개의 터틀심 노드를 실행하라    
### 2. ros2 service list
새로운 터미널에서 ros2 service list 명령어를 실행하여 현재 활성화된 서비스의 목록을 반환한다.     
```
$ros2 service list
/clear
/kill
/reset
/spawn
/teleop_turtle/describe_parameters
/teleop_turtle/get_parameter_types
/teleop_turtle/get_parameters
/teleop_turtle/list_parameters
/teleop_turtle/set_parameters
/teleop_turtle/set_parameters_atomically
/turtle1/set_pen
/turtle1/teleport_absolute
/turtle1/teleport_relative
/turtlesim/describe_parameters
/turtlesim/get_parameter_types
/turtlesim/get_parameters
/turtlesim/list_parameters
/turtlesim/set_parameters
/turtlesim/set_parameters_atomically
```
두개의 노드 모두 이름에 parameters가 있는 동일한 여섯가지 서비스를 가지고 있다. ros2의 거의 모든 노드는 parameter를 기반으로한 인프라 서비스가 있다. 다음 튜토리얼에서 parameters에 대한 더 자세한 설명을 할 것이고, 이번 튜토리얼에서는 parameter서비스를 논의에서 생략할 것이다. 지금은 turtlesim 전용 서비스에 집중해보겠다. /clear, /kill, /reset, /spawn, /turtle1/set_pen, /turtle1/teleport_absolute, /turtle1/teleport_relative 이다.  Use turtlesim, ros2, and rqt 튜토리얼에서 rqt를 사용하여 이러한 서비스중 일부와 상호작용한 것을 기억 할 것이다.    
### 3. ros2 service type
서비스에는 서비스의 요청 및 응답 데이터가 어떻게 구조화되는지를 설명하는 타입이 있다. 즉, 서비스 요청(Request)에 어떤 데이터가 포함되고, 서비스 응답(Response)은 어떤 데이터 구조를 가질지 "타입"으로 정하는 거다. 서비스 타입은 토픽타입과 비슷하게 정의되는데 서비스타입은 요청 메시지와 응답 메시지 두 부분으로 나눠져있다는 점이 차이점이다.     
서비스의 타입을 찾기 위해선 다음의 명령어를 사용한다.    
```
$ros2 service type <service_name>
```
turtlesim의 /clear 서비스를 자세이 보자. 새로운터미널을 열고 다음의 커멘드를 입력한다.     
```
$ros2 service type /clear
std_srvs/srv/Empty
```
Empty 타입은 요청(request)데이터가 아무것도 없고, 응답(response)데이터도 아무것도 없는 단순한 서비스 타입을 말한다. 데이터를 주고 받을 필요가 없는 경우 사용, 예를 들어, 어떤 행동을 시작해, 멈춰라고 신호만 보내도 될 때 사용한다.     
#### 3.1. ros2 sevice list -t
작도하는 모든 서비스의 타입을 보고 싶다면 --show-types옵션(약칭하여 -t)를 list 커멘드에 붙이면 된다.    
```
$ros2 service list -t
/clear [std_srvs/srv/Empty]
/kill [turtlesim/srv/Kill]
/reset [std_srvs/srv/Empty]
/spawn [turtlesim/srv/Spawn]
...
/turtle1/set_pen [turtlesim/srv/SetPen]
/turtle1/teleport_absolute [turtlesim/srv/TeleportAbsolute]
/turtle1/teleport_relative [turtlesim/srv/TeleportRelative]
...
```
### 4. ros2 service find
특정 타입의 모든 서비스를 찾고 싶다면, 다음의 커멘드를 사용하면 된다.    
```
$ros2 service find <type_name>
```
예를 들어 Empty타입을 사용하는 서비스를 찾고 싶다면 다음의 커멘드를 작성하면 다음과 같이 반환값을 얻을 수 있다.   
```
$ros2 service find std_srvs/srv/Empty
/clear
/reset
```
### 5. ros2 interface show
명령줄에서 서비스를 부를수 있지만, input argument의 구조를 먼저 알아야한다.   
```
$ros2 interface show <type_name>
```
/clear 서비스 타입인 Empty에 대해 알아보자.     
```
$ros2 interface show std_srvs/srv/Empty
---
```
여기서 ---는 request 구조(위)와 response 구조(아래)를 나누나. 하지만 이미 배웠다시피 Empty 타입은 어떠한 데이터도 보내거나 받지 않는다. 그렇기에 구조가 비어있게 된다.      
/spawn과 같이 데이터를 보내고 받는 서비스의 타입을 살펴보자. ros2 servvice list -t를 통해 /spawn의 타입은 turtlesim/srv/Spawn이라는 것을 알 수 있다. 따라서 /spawn 서비스의 request와 response 구조를 알기위해 커멘드를 입력하면 다음의 반환값을 얻는다.     
```
$ros2 interface show turtlesim/srv/Spawn
float32 x
float32 y
float32 theta
string name # Optional.  A unique name will be created and returned if this is empty
---
string name
```
--- 위의 정보는 /spawn을 부르기 위해 필요한 인자들을 알려준다. x, y, theta가 생성되는 turtle의 2D pose에 결정하고, name은 선택사항이다.(optional)  라인 아래에 있는 정보는 알아야할 사항은 아니지만, 호출에서 받은 response의 데이터 유형을 이해하는 데 도움이 된다. 정리하자면, ---위: 서비스 요청 인자(입력값) 정의(무엇을 내보내야 하나?, ---아래: 서비스 응답 타입(출력값)정의 (결과로 무엇을 받을 수 있나?)    
### 6. ros2 service call
서비스 타입이 무엇인지, 어떻게 서비스의 타입을 찾는지, 타입의 인자의 구조를 어떻게 찾는지를 알기에, 이제 서비스를 호출 할 수 있다.    
```
$ros2 service call <service_name> <service_type> <arguments>
```
<arguments>부분은 옵션이다. 예를 들어 Empty 타입의 서비스는 아무 인자를 받지 않기에 다음의 명령어를 사용한다.   
```
$ros2 service call /clear std_srvs/srv/Empty
```
이 명령어는 터틀심 윈도우에서 turtle이 그린 어떠한 line도 다 clear해준다.     
<img width="512" height="540" alt="image" src="https://github.com/user-attachments/assets/8e12b7b7-d1d2-4743-838f-037f57dda839" />         
<img width="1243" height="521" alt="image" src="https://github.com/user-attachments/assets/58b37b98-7188-44ba-a93c-155dbba90568" />      
서비스를 호출하자 라인이 사라지는 것을 볼 수 있다.     
이제 /spawn 명령어를 통해 새로운 turtle을 생성해보자. input <arguments>는 YAML 문법에 맞추어 명령줄을 작성하여 서비스를 호출한다. 다음의 명령어를 사용하라.    
```
$ros2 service call /spawn turtlesim/srv/Spawn "{x: 2, y: 2, theta: 0.2, name: ''}"
requester: making request: turtlesim.srv.Spawn_Request(x=2.0, y=2.0, theta=0.2, name='')

response:
turtlesim.srv.Spawn_Response(name='turtle2')
```
이제 무슨일이 일어나고 있는지에 대한 method-style view를 가지게 될 것이고, 그 다음에 서비스 응답을 받는다. 이제 turtlesim 윈도우는 다음과 같이 새로운 turtle이 생성되어 업데이트된다.     
<img width="1243" height="521" alt="image" src="https://github.com/user-attachments/assets/31d83d37-4529-4a1b-9ca1-44975e55fa14" />     

## Summary
ros2에서 노드는 서비스를 이용해 커뮤니케이션할 수 있다. 서비스는 토픽과 같이 한방향 커뮤니게이션(하나 이상의 subscriber가 publishe정보의 노드를 소비하는 것과 같은)이 아닌 요청request/응답response 패턴으로 client라는 노드가 "어떠한 작업을 해달라"라는 request(요청)을 보내 만들면 서비스를 제공하는 노드는 그 요청을 받아서 처리한 뒤 처리 결과를 담은 response(응답)을 다시 클라이언트에게 되돌려준다. 일반적으로 지속적인 호출을 위해 서비스를 이용하고 싶지 않다면, 토픽을 사용하거나 다른 action이 더 알맞을 수 있다. 이번 튜토리얼에선 서비스를 식별하고, 깊게 들여다 보고, 호출하는 명령줄을 사용하는 것을 배웠다. 
