# Understanding topics
* 목표: rqt_graph를 사용하고 ros2 토픽일 살펴보는 명령줄도구를 이용한다.

## Background
ros2는 복잡한 시스템을 여러 모듈형 노드로 나눈다. 토픽은 노드가 메시지를 주고받을 수 있는 버스역할을 하는 ros graph에서 중요한 요소이다.       
<img width="854" height="480" alt="image" src="https://github.com/user-attachments/assets/ebd5f56d-470f-4a75-9a47-9e43d442b168" />     

node는 임의의 토픽에 데이터를 게시(publish)할 수 있으며 동시에 임의의 토픽에 대한 구독(subscriptions)을 가질 수 있다.    
<img width="854" height="480" alt="image" src="https://github.com/user-attachments/assets/50a30ce0-3502-40f8-90b2-208116bf0a81" />       

토픽은 데이터가 노드 간, 즉 시스템의 다른 부분 간에 이동하는 주요 방법 중 하나이다.    
## prerequisites
노드에 대한 정보를 알아야한다.

## Tasks
### 1. Setup
당신은 이제 쉽게 turtlesim을 켤 수 있다. 새로운 터미널을 열어 작동시킨다.    
```
$ros2 run turtlesim turtlesim_node
```
```
$ros2 run turtlesim turtlesim_node
```
이전 튜토리얼에서 이 노드들의 이름이 /turtlesim과 /teleop_turtle이라는 것을 알수 있었다.    
### 2. rqt_graph
이 튜토리얼에서는 rqt_graph를 사용하여 변화하는 노드와 토픽, 그리고 이들 간의 연결을 시각화 할 것이다.    
새로운 터미널을 열어 다음의 커맨드를 실행한다.   
```
$rqt_graph
```
rqt를 열어 Plugins >Introspection > Node Graph를 통해서도 rqt_graph를 실행할 수 있다.     

<img width="985" height="600" alt="image" src="https://github.com/user-attachments/assets/78c096f0-b943-4b09-a24a-07fd8a031433" />     

위의 노드와 토픽뿐만 아니라 그래프 주변의 두가지 동작도 볼 수 있다.(당분간은 무시한다.) 마우스를 중앙의 토픽 위에 올려놓으면 아래의 이미지처럼 색상이 강조되는 것을 볼 수 있다.   
<img width="985" height="600" alt="image" src="https://github.com/user-attachments/assets/9d5acda9-3b4f-4b3c-8eec-dc8906a9f90d" />       
이 graph는 /turtlesim 노드와 /teleop_turtle 노드가  토픽에 대해 어떻게 소통하는지를 묘사하고 있다. /teleop_turtle노드는 /turtle1/cmd_vel 토픽에 데이터(turtle을 움직이기 위해 키를 누른 정보)를 publishing하고 /turtlesim 노드는 이 토픽의 데이터를 받아 subscribde한다.      
rqt_graph의 강조 기능은 여러 노드와 주제가 다양한 방식으로 연결된 더 복잡한 시스템을 검토할 때 매우 유용하다. rqt_graph는 그래픽적으로 살펴볼 수 있는 도구이다. 이제 토픽을 살펴보기 위한 몇가지 명령줄 도구를 살펴보자.     
### 3. ros2 topic list
새로운 터미널에서 ros2 topic list 명령어를 실행하여 현재 시스템에서 작동중인 토픽의 리스트를 받게 된다.    
```
$ros2 topic list
/parameter_events
/rosout
/turtle1/cmd_vel
/turtle1/color_sensor
/turtle1/pose
```
ros2 topic list -t 명령어는 동일한 토픽 목록을 반환하며, 이번에는 토픽유형(메시지 타입)을 괄호안에 추가한다.     
```
$ros2 topic list -t
/parameter_events [rcl_interfaces/msg/ParameterEvent]
/rosout [rcl_interfaces/msg/Log]
/turtle1/cmd_vel [geometry_msgs/msg/Twist]
/turtle1/color_sensor [turtlesim/msg/Color]
/turtle1/pose [turtlesim/msg/Pose]
```
이러한 속성, 특히 type은 노드가 토픽을 넘어 이동할 때에 동일한 정보에 대해 이야기하고 있다는 것을 아는 방법이다. 이러한 rqt_graph에서 토픽을 hide의 박스를 모두 체크표시를 없에면다음과 같이 나오게 된다.        
<img width="554" height="430" alt="image" src="https://github.com/user-attachments/assets/2eea4085-0100-4b4f-b115-f9f46dcd5b87" />     
하지만 지금은 혼란을 피하기 위해 이러한 옵션을 선택하지 않을 것이다.  
### 4. ros2 topic echo
특정 토픽에 publish되는 실시간 데이터를 볼 수 있는 명령어는 다음과 같다.    
```
$ros2 topic echo <topic_name>
```
우리는 /teleop_turtle이 /turtle1/cmd_vel 토픽을 통해 /turtlesim으로 데이터를 publishe한다. 그렇기에 echo를 통해 이 토픽을 자세히 살펴보자.    
```
$ros2 topic echo /turtle1/cmd_vel
```
처음에는 이 명령어가 아무것도 반환하지 않는다. /teleop_turtle가 무언가를 publish 하기를 기다리고 있기 때문이다. 다시 turtle_teleop_key의 터미널로 돌아와서 키보드를 이용해 turtle을 움직여보자. echo를 작동식킨 화면에서 모든 움직임마다 위치데이터가 published되고 있다.      
<img width="1305" height="822" alt="image" src="https://github.com/user-attachments/assets/eecb2b26-837b-40c5-9dcf-78f5d03df8fc" />       

```
linear:
  x: 2.0
  y: 0.0
  z: 0.0
angular:
  x: 0.0
  y: 0.0
  z: 0.0
  ---
```
이제 다시 rqt_graph로 돌아가서 Debug박스를 체크 해제 해본다.     

<img width="984" height="595" alt="image" src="https://github.com/user-attachments/assets/a5e38c88-4473-4c9a-b63e-509c2d8c4cc1" />      

/_ros2cil_3961는 방금실행한  echo명령어에 의해 생성된 노드이다.(이 숫자는 다를수 있다. )이제 publiser가 cmd_vel 토픽에 대한 데이터를 게시하고 있으며, 두개의 subscriber가 subscribed하고 있다는 것을 알 수 있다.       
### 5. ros2 topic info
토픽은 오직 one-to-one 커뮤니케이션만하지 않는다. one-to-many, many-to-one, many-to-many가 가능하다. 다른 방법으로 이것이 작동하는 것을 보자.     
```
$ros2 topic info /turtle1/cmd_vel
Type: geometry_msgs/msg/Twist
Publisher count: 1
Subscription count: 2
```
### 6. ros2 interface show   
노드들은 토픽에 데이터를 보낼 때 메세지를 사용한다. publisher와 subscriber는 의사소통을 위해 무조건 같은 타입의 메세지를 사용해 주고 받아야한다. 토픽의 타입은 이전에 배운 ros2 topic list -t를 실행하여 각 토픽에 어떤 타입의 메시지를 사용하는지 알 수 있다. cmd_vel 토픽의 타입을 다시 보자   
```
/turtle1/cmd_vel [geometry_msgs/msg/Twist]
```
이것의 의미는 geometry_msgs 패키지에 Twist라 불리는 msg가 있다는 뜻이다. 이제 이 타입을 더 디테일하게 알아보기 위해 ros2 interface show <msg_type>이라는 명령어를 실행할 것이다. 구체적으로 메시지가 기대하는 데이터 구조이다.     
```
$ros2 interface show geometry_msgs/msg/Twist
```
이것은 다음을 반환한다.   
<img width="461" height="250" alt="image" src="https://github.com/user-attachments/assets/8131fedf-e3bb-4e76-8699-9ae69dfb4eea" />        
이것은 /turtlesim 노드가 각각 세개의 요소로 이루어진 두 벡터, 즉 linear과 angular의 메시지를 기대하고 있다는 것을 알려준다.    
echo 명령어로 /teleop_turtle이 /turtlesim으로 전달되는 데이터를 기억한다면, 이는 동일한 구조로 작성된 것을 확인 할 수 있다.    
```
linear:
  x: 2.0
  y: 0.0
  z: 0.0
angular:
  x: 0.0
  y: 0.0
  z: 0.0
  ---
```
### 7. ros2 topic pub
이제 메시지 구조를 갖추게 되었으니, 명령줄에서 직접 토픽에 대한 데이터를 publish할 수 있다.     
```
$ros2 topic pub <topic_name> <msg_type> '<args>'
```
'<args>'부분은 이전 섹션에서 찾은 토픽에 전달하는 구조대로 작성한 데이터가 된다. turtle(일반적으로 모방하려는 실제 로봇)은 지속적으로 작동하기 위해 꾸준한 명령어의 흐름이 필요하다. 그렇기에 turtle을 움직이기 위해, 움직임을 유지하기 위해, 다음의 명령어를 사용한다ㅣ. 이 인수는 YAML 구문으로 입력해야 한다는 점에 유의해야한다. 전체명령어를 다음과 같이 입력한다.     
```
$ros2 topic pub /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}"
```
ros2 topic pub 명령어를 별도의 옵션 없이 실행하면, 해당 명령(YAML)로 기술한 메시지 데이터)을 1초에 한번(1Hz주기)로 끊임 없이 반복해서 publish한다는 뜻이다. 
<img width="496" height="534" alt="image" src="https://github.com/user-attachments/assets/8be89e97-6d91-4d0f-a98c-ed7d8bd0bf4d" />     
turtle이 반복해서 도는 모습을 볼 수 있다.     
만약 데이터를 토픽에 딱 한번만(or 무한보다 적게) publish할때에는 만든 명령어에 --once만 붙여주면 된다.    
```
$ros2 topic pub --once /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}"
```
--once는 "메시지 하나를 publish하고 종료"라는 의미의 선택적 인수이다.     
-w 2는 "두개의 일치하는 subscription을 기다리다"라는 의미의 선택적인수이다. 이는 turtlesim과 topic echo 모두 subscribed가 되어있기에 필요하다. 당신은 다음의 output을 터미널에서 얻을 수 있다.     
```
Waiting for at least 2 matching subscription(s)...
publisher: beginning loop
publishing #1: geometry_msgs.msg.Twist(linear=geometry_msgs.msg.Vector3(x=2.0, y=0.0, z=0.0), angular=geometry_msgs.msg.Vector3(x=0.0, y=0.0, z=1.8))
```
그리고 다음과 같이 움직이고 멈추는 것을 볼 수 있다.     
<img width="452" height="483" alt="image" src="https://github.com/user-attachments/assets/9afa37f3-252e-4f2a-830d-33dd01b243f6" />      
우리는 다시 rqt_graph를 통해 어떤 일이 벌어졌는지 시각적으로 확인해보자. ros2 topic pub ... 노드(/_ros2cli_30358)가 /turtle1/cmd_vel토픽을 통해 publishing하고 있고, 이는 현재 ros2 topic echo ... shem(/_ros2cli_26646)와 /turtlesim 노드 모두에 수신되고 있다.      
<img width="547" height="357" alt="image" src="https://github.com/user-attachments/assets/0d404978-f61f-4441-b927-51026873ba5e" />       
마지막으로 pose 토픽에 대해 echo를 실행하고 rqt_graph를 다시 확인해보자.   
```
$ros2 topic echo /turtle1/pose
```
<img width="547" height="357" alt="image" src="https://github.com/user-attachments/assets/a72bda61-3f62-4a1b-b837-cf9369d3356b" />       

/turtlesim 노드가 pose 토픽에 publishing하고 있고, 새로운 echo노드가 이를 subscribed하고 있다. 타임스탬프가 포함된 메시지를 publiahing할 때, pub 명령어가 현재 시간으로 자동으로 작성하는 두가지 방법이 있다.     
std_msgs/msg/Header 타입이 있는 메시지를 ros2 topic pub 명령어로 publish할 때, 메시지의 header 필드에 "auto"라고 입력하면, ros2가 메시지를 발행하는 시점의 현재 시간(타임스탬프)를 header.stamp 필드에 자동으로 채워준다. 즉, 개발자가 수동으로 현재 시각을 코드로 입력하지 않아도, "auto"옵션만 주면 ros2가 알아서 해당 필드에 현재 시간을 넣어주기에, 실시간/동기화 데이터가 자연스럽게 만들어진다. (#header란?메시지 데이터의 메타정보를 담는 표준필드이다. stamp, frame_id, seq가 포함된다.즉, header는 시간과 좌표계 정보를 포함하여 메시지가 언제, 어디서 생성된 것인지를 알려주는 메타정보 역할을 한다.  ROS에서는 시간 동기화나 좌표 변환 시에 이 header 정보가 아주 중요하다.)    
```
$ros2 topic pub /pose geometry_msgs/msg/PoseStamped '{header: "auto", pose: {position: {x: 1.0, y: 2.0, z: 3.0}}}'
```
만약 메시지가 full headr를 사용하지 않고, 그저 builtin_interfaces/msg/Time 타입 필드만 가지고 있다면, 그 필드를 'now'값으로 설정할 수 있다. 
```
$ros2 topic pub /reference sensor_msgs/msg/TimeReference '{header: "auto", time_ref: "now", source: "dumy"}'
```
